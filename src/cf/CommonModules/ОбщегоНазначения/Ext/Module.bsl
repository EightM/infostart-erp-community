// Преобразует (сериализует) любое значение в XML-строку.
// Преобразованы в могут быть только те объекты, для которых в синтакс-помощнике указано, что они сериализуются.
// См. также ЗначениеИзСтрокиXML.
//
// Параметры:
//  Значение - Произвольный - значение, которое необходимо сериализовать в XML-строку.
//
// Возвращаемое значение:
//  Строка - XML-строка.
//
Функция ЗначениеВСтрокуXML(Значение) Экспорт
	ЗаписьXML=Новый ЗаписьXML;
	ЗаписьXML.УстановитьСтроку();
	СериализаторXDTO.ЗаписатьXML(ЗаписьXML, Значение, НазначениеТипаXML.Явное);	
	Возврат ЗаписьXML.Закрыть();
КонецФункции

// Выполняет преобразование (десериализацию) XML-строки в значение.
// См. также ЗначениеВСтрокуXML.
//
// Параметры:
//  СтрокаXML - Строка - XML-строка, с сериализованным объектом..
//
// Возвращаемое значение:
//  Произвольный - значение, полученное из переданной XML-строки.
//
Функция ЗначениеИзСтрокиXML(СтрокаXML) Экспорт
	ЧтениеXML=Новый ЧтениеXML;
	ЧтениеXML.УстановитьСтроку(СтрокаXML);	
	Возврат СериализаторXDTO.ПрочитатьXML(ЧтениеXML);
КонецФункции

// Функция СтрокаТаблицыЗначенийВСтруктуру создает
// структуру со свойствами, как колонки таблицы
// значений передаваемой строки
// и устанавливает этим свойствам значения
// из строки таблицы значений
// 
// Параметры:
//  СтрокаТаблицыЗначений - СтрокаТаблицыЗначений
//
// ВозвращаемоеЗначение:
//  Структура
//
Функция СтрокаТаблицыЗначенийВСтруктуру(СтрокаТаблицыЗначений) Экспорт
	Структура=Новый Структура;
	Для каждого Колонка Из СтрокаТаблицыЗначений.Владелец().Колонки Цикл
		Структура.Вставить(Колонка.Имя, СтрокаТаблицыЗначений[Колонка.Имя]);
	КонецЦикла;
	
	Возврат Структура;	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// Функции для поддержки работы конфигурации с профилем безопасности, в котором
// запрещено подключение внешних модулей без установки безопасного режима.
//

// Выполнить экспортную процедуру по имени с уровнем привилегий конфигурации.
// При включении профилей безопасности для вызова оператора Выполнить() используется
// переход в безопасный режим с профилем безопасности, используемом для информационной базы
// (если выше по стеку не был установлен другой безопасный режим).
//
// Параметры:
//  ИмяМетода  - Строка - имя экспортной процедуры в формате
//                       <имя объекта>.<имя процедуры>, где <имя объекта> - это
//                       общий модуль или модуль менеджера объекта.
//  Параметры  - Массив - параметры передаются в процедуру <ИмяЭкспортнойПроцедуры>
//                        в порядке расположения элементов массива.
// 
// Пример:
//  Параметры = Новый Массив();
//  Параметры.Добавить("1");
//  ОбщегоНазначения.ВыполнитьМетодКонфигурации("МойОбщийМодуль.МояПроцедура", Параметры);
//
Процедура ВыполнитьМетодКонфигурации(Знач ИмяМетода, Знач Параметры = Неопределено) Экспорт
	ПроверитьИмяПроцедурыКонфигурации(ИмяМетода);
	
	//Если ПодсистемаСуществует("СтандартныеПодсистемы.ПрофилиБезопасности") Тогда
	//	МодульРаботаВБезопасномРежиме = ОбщийМодуль("РаботаВБезопасномРежиме");
	//	Если МодульРаботаВБезопасномРежиме.ИспользуютсяПрофилиБезопасности() И Не МодульРаботаВБезопасномРежиме.УстановленБезопасныйРежим() Тогда
	//		ПрофильИнформационнойБазы = МодульРаботаВБезопасномРежиме.ПрофильБезопасностиИнформационнойБазы();
	//		Если ЗначениеЗаполнено(ПрофильИнформационнойБазы) Тогда
	//			УстановитьБезопасныйРежим(ПрофильИнформационнойБазы);
	//			Если БезопасныйРежим() = Истина Тогда
	//				УстановитьБезопасныйРежим(Ложь);
	//			КонецЕсли;
	//		КонецЕсли;
	//	КонецЕсли;
	//КонецЕсли;
	
	ПараметрыСтрока = "";
	Если Параметры <> Неопределено И Параметры.Количество() > 0 Тогда
		Для Индекс = 0 По Параметры.ВГраница() Цикл 
			ПараметрыСтрока = ПараметрыСтрока + "Параметры[" + Индекс + "],";
		КонецЦикла;
		ПараметрыСтрока = Сред(ПараметрыСтрока, 1, СтрДлина(ПараметрыСтрока) - 1);
	КонецЕсли;
	
	Выполнить ИмяМетода + "(" + ПараметрыСтрока + ")";	
КонецПроцедуры



// Возвращает признак работы в режиме разделения данных по областям
// (технически это признак условного разделения).
// 
// Возвращает Ложь, если конфигурация не может работать в режиме разделения данных
// (не содержит общих реквизитов, предназначенных для разделения данных).
//
// Возвращаемое значение:
//  Булево - Истина, если разделение включено.
//         - Ложь,   если разделение выключено или не поддерживается.
//
Функция РазделениеВключено() Экспорт
	Возврат Ложь;	
КонецФункции

Функция ПредметСтрокой(СсылкаНаПредмет) Экспорт
	//////
	//////Результат = "";
	//////
	//////Если СсылкаНаПредмет = Неопределено Или СсылкаНаПредмет.Пустая() Тогда
	//////	Результат = НСтр("ru = 'не задан'");
	//////ИначеЕсли Метаданные.Документы.Содержит(СсылкаНаПредмет.Метаданные()) Тогда
	//////	Результат = Строка(СсылкаНаПредмет);
	//////Иначе
	//////	ПредставлениеОбъекта = СсылкаНаПредмет.Метаданные().ПредставлениеОбъекта;
	//////	Если ПустаяСтрока(ПредставлениеОбъекта) Тогда
	//////		ПредставлениеОбъекта = СсылкаНаПредмет.Метаданные().Представление();
	//////	КонецЕсли;
	//////	Результат = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку("%1 (%2)", Строка(СсылкаНаПредмет), ПредставлениеОбъекта);
	//////КонецЕсли;
	//////
	//////Возврат Результат;
	
КонецФункции

//	Преобразует таблицу значений в массив.
//	Может использоваться для передачи на клиента данных, полученных
//	на сервере в виде таблицы значений в том случае, если таблица
//	значений содержит только такие значения, которые могут
//  быть переданы на клиента.
//
//	Полученный массив содержит структуры, каждая из которых повторяет
//	структуру колонок таблицы значений.
//
//	Не рекомендуется использовать для преобразования таблиц значений
//	с большим количеством строк.
//
//	Параметры: 
//    ТаблицаЗначений - ТаблицаЗначений.
//
//	Возвращаемое значение: 
//    Массив
//
Функция ТаблицаЗначенийВМассив(ТаблицаЗначений) Экспорт
	
	Массив = Новый Массив();
	СтруктураСтрокой = "";
	НужнаЗапятая = Ложь;
	Для Каждого Колонка Из ТаблицаЗначений.Колонки Цикл
		Если НужнаЗапятая Тогда
			СтруктураСтрокой = СтруктураСтрокой + ",";
		КонецЕсли;
		СтруктураСтрокой = СтруктураСтрокой + Колонка.Имя;
		НужнаЗапятая = Истина;
	КонецЦикла;
	Для Каждого Строка Из ТаблицаЗначений Цикл
		НоваяСтрока = Новый Структура(СтруктураСтрокой);
		ЗаполнитьЗначенияСвойств(НоваяСтрока, Строка);
		Массив.Добавить(НоваяСтрока);
	КонецЦикла;
	Возврат Массив;

КонецФункции

Процедура УстановитьНовоеЗначение(Параметр, Значение) Экспорт 
	Если НЕ Параметр=Значение Тогда Параметр=Значение; КонецЕсли;
КонецПроцедуры

Функция ПривестиСтрокуКЧислу(ЧислоСтрокой, ВозвращатьНеопределено = Ложь) Экспорт
    
    ОписаниеТипаЧисла = Новый ОписаниеТипов("Число");
    ЗначениеЧисла = ОписаниеТипаЧисла.ПривестиЗначение(ЧислоСтрокой);
    
    Если ВозвращатьНеопределено И (ЗначениеЧисла = 0) Тогда
        
        Стр = Строка(ЧислоСтрокой);
        Если Стр = "" Тогда
            Возврат Неопределено;
        КонецЕсли;
        
        Стр = СтрЗаменить(СокрЛП(Стр), "0", "");
        Если (Стр <> "") И (Стр <> ".") И (Стр <> ",") Тогда
            Возврат Неопределено;
        КонецЕсли;
    КонецЕсли;
    
    Возврат ЗначениеЧисла;    
    
КонецФункции

Функция ЭтоСсылка(Значение) Экспорт
	текТипЗнч=ТипЗнч(Значение);

	Если Справочники.ТипВсеСсылки().СодержитТип(текТипЗнч) Тогда
    	Возврат Истина;
	ИначеЕсли Документы.ТипВсеСсылки().СодержитТип(текТипЗнч) Тогда
    	Возврат Истина;
	ИначеЕсли ПланыВидовХарактеристик.ТипВсеСсылки().СодержитТип(текТипЗнч) Тогда
		Возврат Истина;
	ИначеЕсли ПланыСчетов.ТипВсеСсылки().СодержитТип(текТипЗнч) Тогда
		Возврат Истина;
	ИначеЕсли Задачи.ТипВсеСсылки().СодержитТип(текТипЗнч) Тогда
		Возврат Истина;
	ИначеЕсли БизнесПроцессы.ТипВсеСсылки().СодержитТип(текТипЗнч) Тогда
		Возврат Истина;
	ИначеЕсли Перечисления.ТипВсеСсылки().СодержитТип(текТипЗнч) Тогда
		Возврат Истина;
	КонецЕсли;

	Возврат Ложь; 
КонецФункции

// Получить представление физического места размещения информационной базы для отображения администратору.
//
// Возвращаемое значение:
//   Строка      - представление информационной базы
//
// Пример возвращаемого результата:
// - для ИБ в файлом режиме: \\FileServer\1c_ib\
// - для ИБ в серверном режиме: ServerName:1111 / information_base_name
//
Функция ПолучитьПредставлениеИнформационнойБазы() Экспорт
	СтрокаСоединенияСБД = СтрокаСоединенияИнформационнойБазы();

	Если ИнформационнаяБазаФайловая(СтрокаСоединенияСБД) Тогда
		Возврат Сред(СтрокаСоединенияСБД, 6, СтрДлина(СтрокаСоединенияСБД) - 6);
	КонецЕсли;

	// Прибавить к имени сервера имя пути информационной базы
	ПозицияПоиска = Найти(Врег(СтрокаСоединенияСБД), "SRVR=");
	Если ПозицияПоиска <> 1 Тогда Возврат Неопределено; КонецЕсли;
	
	ПозицияТочкиСЗапятой = Найти(СтрокаСоединенияСБД, ";");
	НачальнаяПозицияКопирования = 6 + 1;
	КонечнаяПозицияКопирования = ПозицияТочкиСЗапятой - 2; 
	
	ИмяСервера = Сред(СтрокаСоединенияСБД, НачальнаяПозицияКопирования, КонечнаяПозицияКопирования - НачальнаяПозицияКопирования + 1);
	
	СтрокаСоединенияСБД = Сред(СтрокаСоединенияСБД, ПозицияТочкиСЗапятой + 1);
	
	// Позиция имени сервера
	ПозицияПоиска = Найти(Врег(СтрокаСоединенияСБД), "REF=");
	Если ПозицияПоиска <> 1 Тогда Возврат Неопределено; КонецЕсли;
	
	НачальнаяПозицияКопирования = 6;
	ПозицияТочкиСЗапятой = Найти(СтрокаСоединенияСБД, ";");
	КонечнаяПозицияКопирования = ПозицияТочкиСЗапятой - 2; 
	
	ИмяИБНаСервере = Сред(СтрокаСоединенияСБД, НачальнаяПозицияКопирования, КонечнаяПозицияКопирования - НачальнаяПозицияКопирования + 1);
	ПутьКБД = ИмяСервера + "/ " + ИмяИБНаСервере;

	Возврат ПутьКБД;	
КонецФункции


// Создает временный каталог. После окончания работы с временным каталогом его необходимо удалить 
// с помощью ОбщегоНазначения.УдалитьВременныйКаталог.
//
// Параметры:
//   Расширение - Строка - Расширение каталога, которое идентифицирует назначение временного каталога
//                         и подсистему, которая его создала.
//                         Рекомендуется указывать на английском языке.
//
// Возвращаемое значение:
//   Строка - Полный путь к каталогу с разделителем пути.
//
Функция СоздатьВременныйКаталог(Знач Расширение = "") Экспорт
	ПутьККаталогу=ОбщегоНазначенияКлиентСервер.ДобавитьКонечныйРазделительПути(ПолучитьИмяВременногоФайла(Расширение));
	СоздатьКаталог(ПутьККаталогу);
	Возврат ПутьККаталогу;	
КонецФункции

// Удаляет временный каталог вместе с его содержимым, если возможно.
// Если временный каталог не может быть удален (например, он занят каким-то процессом),
// то в журнал регистрации записывается соответствующее предупреждение, а процедура завершается.
//
// Для совместного использования с ОбщегоНазначения.СоздатьВременныйКаталог, 
// после окончания работы с временным каталогом.
//
// Параметры:
//   ПутьККаталогу - Строка - Полный путь к временному каталогу.
//
Процедура УдалитьВременныйКаталог(Знач ПутьККаталогу) Экспорт
	// Ожидается, что ПутьККаталогу получен методом ПолучитьИмяВременногоФайла().
	// Перед проверкой разворачиваем слэши в одну сторону.
	Если Не СтрНачинаетсяС(СтрЗаменить(ПутьККаталогу, "/", "\"), СтрЗаменить(КаталогВременныхФайлов(), "/", "\")) Тогда
		ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Неверное значение параметра ПутьККаталогу в ОбщегоНазначения.УдалитьВременныйКаталог:
				       |Каталог не является временным ""%1""'"), 
			ПутьККаталогу);
	КонецЕсли;

	Попытка
		УдалитьФайлы(ПутьККаталогу);
	Исключение
		ЗаписьЖурналаРегистрации(НСтр("ru = 'Стандартные подсистемы'", ОбщегоНазначенияКлиентСервер.КодОсновногоЯзыка()),
			УровеньЖурналаРегистрации.Предупреждение,,,
			СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(НСтр("ru = 'Не удалось удалить временный каталог ""%1"" по причине:
			|%2'"),	ПутьККаталогу, ПодробноеПредставлениеОшибки(ИнформацияОбОшибке())));
	КонецПопытки;			
КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С ВАЛЮТАМИ

Функция ПересчитатьИзВалютыВВалюту(Сумма, ВалютаНач, ВалютаКон, ПоКурсуНач, ПоКурсуКон, ПоКратностьНач=1, ПоКратностьКон = 1 ) Экспорт

	Если ВалютаНач = ВалютаКон Тогда Возврат Сумма; КонецЕсли;
	Если ПоКурсуНач = ПоКурсуКон и ПоКратностьНач = ПоКратностьКон Тогда Возврат Сумма; КонецЕсли;

	Если ПоКурсуНач=0 Или ПоКурсуКон=0 Или ПоКратностьНач=0 Или ПоКратностьКон=0 Тогда
		СообщитьОбОшибке("ПересчитатьИзВалютыВВалюту(): при пересчете обнаружен нулевой курс.");
		Возврат 0;
	КонецЕсли;

	Возврат Окр((Сумма * ПоКурсуНач * ПоКратностьКон) / (ПоКурсуКон * ПоКратностьНач), 2);

КонецФункции

Функция ПрочитатьXMLВТаблицу(Знач XML) Экспорт
	
	Если ТипЗнч(XML) <> Тип("ЧтениеXML") Тогда
		Чтение = Новый ЧтениеXML;
		Чтение.УстановитьСтроку(XML);
	Иначе
		Чтение = XML;
	КонецЕсли;
	
	// Прочитаем первый узел и проверим его.
	Если Не Чтение.Прочитать() Тогда
		ВызватьИсключение НСтр("ru = 'Пустой XML'");
	ИначеЕсли Чтение.Имя <> "Items" Тогда
		ВызватьИсключение НСтр("ru = 'Ошибка в структуре XML'");
	КонецЕсли;
	
	// Получим описание таблицы и создадим ее.
	ИмяТаблицы = Чтение.ПолучитьАтрибут("Description");
	ИменаКолонок = СтрЗаменить(Чтение.ПолучитьАтрибут("Columns"), ",", Символы.ПС);
	Колонок = СтрЧислоСтрок(ИменаКолонок);
	
	ТаблицаЗначений = Новый ТаблицаЗначений;
	Для Сч = 1 По Колонок Цикл
		ТаблицаЗначений.Колонки.Добавить(СтрПолучитьСтроку(ИменаКолонок, Сч), Новый ОписаниеТипов("Строка"));
	КонецЦикла;
	
	// Заполним значения в таблице.
	Пока Чтение.Прочитать() Цикл
		
		Если Чтение.ТипУзла = ТипУзлаXML.КонецЭлемента И Чтение.Имя = "Items" Тогда
			Прервать;
		ИначеЕсли Чтение.ТипУзла <> ТипУзлаXML.НачалоЭлемента Тогда
			Продолжить;
		ИначеЕсли Чтение.Имя <> "Item" Тогда
			ВызватьИсключение НСтр("ru = 'Ошибка в структуре XML'");
		КонецЕсли;
		
		новСтр = ТаблицаЗначений.Добавить();
		Для Сч = 1 По Колонок Цикл
			ИмяКолонки = СтрПолучитьСтроку(ИменаКолонок, Сч);
			новСтр[Сч-1] = Чтение.ПолучитьАтрибут(ИмяКолонки);
		КонецЦикла;
		
	КонецЦикла;
	
	// Заполним результат
	Результат = Новый Структура;
	Результат.Вставить("ИмяТаблицы", ИмяТаблицы);
	Результат.Вставить("Данные", ТаблицаЗначений);
	
	Возврат Результат;
	
КонецФункции

Функция ПустоеЗначение(Значение) Экспорт
	Результат=Ложь;
	ТипЗначения=ТипЗнч(Значение);
	Если Значение=Неопределено Тогда
		Результат=Истина;
	ИначеЕсли Значение=NULL Тогда
		Результат=Истина;
	ИначеЕсли ТипЗначения=Тип("Строка") Тогда
		Если СокрЛП(Значение)="" Тогда Результат=Истина; КонецЕсли;
	ИначеЕсли ТипЗначения=Тип("Число") Тогда
		Если Значение=0 Тогда Результат=Истина; КонецЕсли;
	ИначеЕсли ТипЗначения=Тип("Дата") Тогда
		Если Значение=Дата('00010101') Тогда Результат=Истина; КонецЕсли;
	ИначеЕсли ТипЗначения=Тип("Булево") Тогда
		Результат=Ложь; // Булево будем считать не пустым
		// Для остальных будем считать значение пустым, если оно равно
		// дефолтному значению своего типа
	Иначе
		Если Значение=Новый(ТипЗначения) Тогда Результат=Истина; КонецЕсли;
	КонецЕсли;
	Возврат Результат;
КонецФункции

Функция МодульЧисла(Значение) Экспорт
	Возврат ?(Значение<0, -Значение, Значение);
КонецФункции

Процедура ПереместитьЭлемент(Элемент, стрНаправление)Экспорт
	стрТипОбъекта=УправлениеКонфигурациейСервер.ТипОбъекта(Элемент);
	стрВидОбъекта=Элемент.Метаданные().Имя; ЭлементОбмена="";
	Если Элемент.Метаданные().Владельцы<>Неопределено Тогда текВладелец=Элемент.Владелец; КонецЕсли; 
	Если стрТипОбъекта="Справочник" Тогда
		ОбъектВыборка=Справочники[стрВидОбъекта].Выбрать(Элемент.Родитель, текВладелец,,"Код");
	ИначеЕсли стрТипОбъекта="ПланВидовХарактеристик" Тогда
		ОбъектВыборка=ПланыВидовХарактеристик[стрВидОбъекта].Выбрать(Элемент.Родитель, текВладелец, "Код");
	КонецЕсли; 
	Пока ОбъектВыборка.Следующий() Цикл
		Если Элемент.Родитель<>ОбъектВыборка.Родитель Тогда Продолжить;	КонецЕсли;
		Если ОбъектВыборка.Ссылка<>Элемент.Ссылка Тогда ЭлементОбмена=ОбъектВыборка.Ссылка; Продолжить; КонецЕсли;
		Если стрНаправление="Вверх" Тогда Прервать; Иначе ЭлементОбмена=""; КонецЕсли;
		Если ОбъектВыборка.Следующий() Тогда
			Если Элемент.Родитель<>ОбъектВыборка.Родитель Тогда Продолжить;	КонецЕсли;
			ЭлементОбмена=ОбъектВыборка.Ссылка;
		КонецЕсли;
		Прервать;
	КонецЦикла;
	Если ЭлементОбмена="" Тогда Возврат; КонецЕсли;

	КодНовый=ЭлементОбмена.Код;
	КодСтарый=Элемент.Код;

	Объект=Элемент.Ссылка.ПолучитьОбъект();
	Объект.Код=0;
	Объект.Записать();

	Объект=ЭлементОбмена.Ссылка.ПолучитьОбъект();
	Объект.Код=КодСтарый;
	Объект.Записать();

	Объект=Элемент.Ссылка.ПолучитьОбъект();
	Объект.Код=КодНовый;
	Объект.Записать();
КонецПроцедуры

// Преобразует временную таблицу в таблицу значений
//
// Параметры
//  МенеджерВременныхТаблиц – МенеджерВременныхТаблиц в котором хранится временная таблица.
//  ИмяВременнойТаблицы - Строка с именем временной таблицы
//  Уничтожить   – Булево, признак определяющий необходимость уничтожения временной таблицы.
//
Функция ПолчитьТаблицуИзВременнойТаблицы(МенеджерВременныхТаблиц, ИмяВременнойТаблицы, Уничтожить = Ложь) Экспорт

	Запрос=Новый Запрос;
	Запрос.МенеджерВременныхТаблиц = МенеджерВременныхТаблиц;
	Запрос.Текст="ВЫБРАТЬ * ИЗ "+ИмяВременнойТаблицы;

	ТаблицаРезультата=Запрос.Выполнить().Выгрузить();
	Если Уничтожить Тогда
		Запрос=Новый Запрос;
		Запрос.МенеджерВременныхТаблиц=МенеджерВременныхТаблиц;
		Запрос.Текст="УНИЧТОЖИТЬ "+ИмяВременнойТаблицы;
		Запрос.Выполнить();
	КонецЕсли;

	Возврат ТаблицаРезультата;	
КонецФункции

// Функция предназначена для формирования массива префиксов.
//
// Возвращаемое значение.
//  Массив префиксов
//
Функция ПолучитьМассивПрефиксовРИБ() Экспорт
	
	МассивПрефиксов = Новый Массив();

	Запрос=Новый Запрос();
	Запрос.Текст="
	|ВЫБРАТЬ Различные
	|	ПрефиксыИнформационныхБаз.Префикс КАК Префикс
	|ИЗ
	|	РегистрСведений.ПрефиксыИнформационныхБаз КАК ПрефиксыИнформационныхБаз
	|";
	ВыборкаУзлов=Запрос.Выполнить().Выбрать();
	Пока ВыборкаУзлов.Следующий() Цикл
		Если Не ПустаяСтрока(ВыборкаУзлов.Префикс) Тогда
			МассивПрефиксов.Добавить(ВыборкаУзлов.Префикс);
		КонецЕсли;
	КонецЦикла;	
	
	Возврат МассивПрефиксов;
	
КонецФункции

// Функция предназначена для формирования массива префиксов.
//
// Параметры:
//  Организация - (СправочникСсылка), дял которой нужно получить префиксы.
//
// Возвращаемое значение.
//  Массив префиксов
//
Функция СформироватьМассивПрефиксовДляРИБИОрганизации(Организация) Экспорт
	
	МассивПрефиксов = ПолучитьМассивПрефиксовРИБ();	
	
	Если ЗначениеЗаполнено(Организация) Тогда
		
		Префикс = СокрЛП(Организация.Префикс);
		
		Если Префикс <> "" Тогда
			МассивПрефиксов.Добавить(Префикс);
		КонецЕсли;
		
	КонецЕсли;
	
	Если МассивПрефиксов.Количество() = 0 Тогда
		МассивПрефиксов.Добавить("");
	КонецЕсли;
	
	Возврат МассивПрефиксов;
	
КонецФункции

// Функция формирует представление суммы прописью в указанной валюте
//
// Возвращаемое значение:
//  Строка - сумма прописью
//
Функция СформироватьСуммуПрописью(Сумма, Валюта) Экспорт
	Если Валюта.ПараметрыПрописиНаРусском = "" Тогда Возврат ФорматСумм(Сумма); КонецЕсли;
	Возврат ЧислоПрописью(Сумма, "L=ru_RU", Валюта.ПараметрыПрописиНаРусском);
КонецФункции

// Функция формирует представление заголовка документа
//
// Возвращаемое значение:
//  Строка - представление номера документа
//
Функция СформироватьЗаголовокДокумента(ДокументОбъект, НазваниеДокумента = "") Экспорт
	Возврат НазваниеДокумента+" № "+ОбщегоНазначенияСервер.НомерНаПечать(ДокументОбъект)+" от "+Формат(ДокументОбъект.Дата, "ДФ='дд ММММ гггг'") + " г.";
КонецФункции

// Функция определяет наличие хотя бы одной записи в регистре сведений
//
// Параметры
//  ИмяРегистра - строка
//
// Возвращаемое значение:
//   Булево
//
Функция ЕстьЗаписиВРегистреСведений(ИмяРегистра) Экспорт
	Запрос=Новый Запрос;
	Запрос.Текст="
	|ВЫБРАТЬ ПЕРВЫЕ 1
	|	ИсточникДанных.*
	|ИЗ
	|	РегистрСведений."+ИмяРегистра+" КАК ИсточникДанных
	|";
	Возврат НЕ Запрос.Выполнить().Пустой();
КонецФункции

// Получает имя значения перечисления как объекта метаданных
//
// Параметры:
//  Значение - значение перечисления для которого необходимо получить имя перечисления
//
// Возвращаемое значение:
//  Строка - имя значения перечисления как объекта метаданных
//
Функция ИмяЗначенияПеречисления(Значение) Экспорт	
	ОбъектМетаданных = Значение.Метаданные();	
	ИндексЗначения = Перечисления[ОбъектМетаданных.Имя].Индекс(Значение);	
	Возврат ОбъектМетаданных.ЗначенияПеречисления[ИндексЗначения].Имя;
КонецФункции 

// Определяет принадлежность объекта метаданных к общему типу "Документ"
//
// Параметры:
//  ОбъектМетаданных – объект метаданных, для которого необходимо определить принадлежность к заданному типу
// 
//  Возвращаемое значение:
//  Тип: Булево. Истина – объект метаданных принадлежит заданному типу; Ложь – нет.
//
Функция ЭтоДокумент(ОбъектМетаданных) Экспорт
	Возврат УправлениеМетаданными.ИмяБазовогоТипа(ОбъектМетаданных) = "Документы";	
КонецФункции

// Функция ИнформационнаяБазаФайловая определяет режим эксплуатации
// информационной базы файловый (Истина) или Серверный (Ложь).
//  При проверке используется СтрокаСоединенияИнформационнойБазы, которую
// можно указать явно.
//
// Параметры:
//  СтрокаСоединенияИнформационнойБазы - Строка - параметр используется, если
//                 нужно проверить строку соединения не текущей информационной базы.
//
// Возвращаемое значение:
//  Булево.
//
Функция ИнформационнаяБазаФайловая(Знач СтрокаСоединенияИнформационнойБазы = "") Экспорт			
	Если ПустаяСтрока(СтрокаСоединенияИнформационнойБазы) Тогда
		СтрокаСоединенияИнформационнойБазы =  СтрокаСоединенияИнформационнойБазы();
	КонецЕсли;
	Возврат Найти(Врег(СтрокаСоединенияИнформационнойБазы), "FILE=") = 1;	
КонецФункции 

// Процедура удаляет из массива МассивРеквизитов элементы, соответствующие именам 
// реквизитов объекта из массива МассивНепроверяемыхРеквизитов.
// Для использования в обработчиках события ОбработкаПроверкиЗаполнения.
//
// Параметры:
//	МассивРеквизитов              - Массив - массив строк с именами реквизитов объекта.
//	МассивНепроверяемыхРеквизитов - Массив строк с именами реквизитов объекта, не требующих проверки.
//
Процедура УдалитьНепроверяемыеРеквизитыИзМассива(МассивРеквизитов, МассивНепроверяемыхРеквизитов) Экспорт
	
	Для Каждого ЭлементМассива Из МассивНепроверяемыхРеквизитов Цикл
	
		ПорядковыйНомер = МассивРеквизитов.Найти(ЭлементМассива);
		Если ПорядковыйНомер <> Неопределено Тогда
			МассивРеквизитов.Удалить(ПорядковыйНомер);
		КонецЕсли;
	
	КонецЦикла;
	
КонецПроцедуры

// Фиксирует данные типов Структура, Соответствие, Массив с учетом вложенности.
//
// Параметры:
//  Данные - Структура, Соответствие, Массив - коллекции, значения которых являются примитивными типами,
//           хранилищем значения или не могут быть изменены. Поддерживаются типы значений:
//           Булево, Строка, Число, Дата, Неопределено, УникальныйИдентификатор, Null, Тип,
//           ХранилищеЗначения, ОбщийМодуль, ОбъектМетаданных, ТипЗначенияXDTO, ТипОбъектаXDTO,
//           ЛюбаяСсылка.
//
//  ВызыватьИсключение - Булево - начальное значение Истина. Когда установлено.
//                       Ложь, тогда в случае наличия нефиксируемых данных исключение не будет
//                       вызвано, при этом данные будут зафиксированы на сколько возможно.
//
// Возвращаемое значение:
//  Фиксированные данные, аналогичные переданным в параметре Данные.
// 
Функция ФиксированныеДанные(Данные, ВызыватьИсключение = Истина) Экспорт
	
	Если ТипЗнч(Данные) = Тип("Массив") Тогда
		Массив = Новый Массив;
		
		Индекс = Данные.Количество() - 1;
		
		Для каждого Значение Из Данные Цикл
			
			Если ТипЗнч(Значение) = Тип("Структура")
			 ИЛИ ТипЗнч(Значение) = Тип("Соответствие")
			 ИЛИ ТипЗнч(Значение) = Тип("Массив") Тогда
				
				Массив.Добавить(ФиксированныеДанные(Значение, ВызыватьИсключение));
			Иначе
				Если ВызыватьИсключение Тогда
					ПроверкаФиксированностиДанных(Значение, Истина);
				КонецЕсли;
				Массив.Добавить(Значение);
			КонецЕсли;
		КонецЦикла;
		
		Возврат Новый ФиксированныйМассив(Массив);
		
	ИначеЕсли ТипЗнч(Данные) = Тип("Структура")
	      ИЛИ ТипЗнч(Данные) = Тип("Соответствие") Тогда
		
		Если ТипЗнч(Данные) = Тип("Структура") Тогда
			Коллекция = Новый Структура;
		Иначе
			Коллекция = Новый Соответствие;
		КонецЕсли;
		
		Для каждого КлючИЗначение Из Данные Цикл
			Значение = КлючИЗначение.Значение;
			Если ТипЗнч(Значение) = Тип("Структура") ИЛИ ТипЗнч(Значение) = Тип("Соответствие") ИЛИ ТипЗнч(Значение) = Тип("Массив") Тогда
				Коллекция.Вставить(КлючИЗначение.Ключ, ФиксированныеДанные(Значение, ВызыватьИсключение));
			Иначе
				Если ВызыватьИсключение Тогда
					ПроверкаФиксированностиДанных(Значение, Истина);
				КонецЕсли;
				Коллекция.Вставить(КлючИЗначение.Ключ, Значение);
			КонецЕсли;
		КонецЦикла;
		
		Если ТипЗнч(Данные) = Тип("Структура") Тогда
			Возврат Новый ФиксированнаяСтруктура(Коллекция);
		КонецЕсли;

		Возврат Новый ФиксированноеСоответствие(Коллекция);
		
	ИначеЕсли ВызыватьИсключение Тогда
		ПроверкаФиксированностиДанных(Данные);
	КонецЕсли;
	
	Возврат Данные;	
КонецФункции

Процедура ПроверкаФиксированностиДанных(Данные, ДанныеВЗначенииФиксированныхТипов = Ложь)
	
	ТипДанных = ТипЗнч(Данные);
	
	Если ТипДанных = Тип("ХранилищеЗначения")
	 ИЛИ ТипДанных = Тип("ФиксированныйМассив")
	 ИЛИ ТипДанных = Тип("ФиксированнаяСтруктура")
	 ИЛИ ТипДанных = Тип("ФиксированноеСоответствие") Тогда
		
		Возврат;
	КонецЕсли;
	
	Если ДанныеВЗначенииФиксированныхТипов Тогда
		
		Если ТипДанных = Тип("Булево")
		 ИЛИ ТипДанных = Тип("Строка")
		 ИЛИ ТипДанных = Тип("Число")
		 ИЛИ ТипДанных = Тип("Дата")
		 ИЛИ ТипДанных = Тип("Неопределено")
		 ИЛИ ТипДанных = Тип("УникальныйИдентификатор")
		 ИЛИ ТипДанных = Тип("Null")
		 ИЛИ ТипДанных = Тип("Тип")
		 ИЛИ ТипДанных = Тип("ХранилищеЗначения")
		 ИЛИ ТипДанных = Тип("ОбщийМодуль")
		 ИЛИ ТипДанных = Тип("ОбъектМетаданных")
		 ИЛИ ТипДанных = Тип("ТипЗначенияXDTO")
		 ИЛИ ТипДанных = Тип("ТипОбъектаXDTO")
		 ИЛИ ЭтоСсылка(ТипДанных) Тогда
			
			Возврат;
		КонецЕсли;
	КонецЕсли;
	
	ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
		НСтр("ru = 'Ошибка в функции ФиксированныеДанные общего модуля ОбщегоНазначения.
		           |Данные типа ""%1"" не могут быть зафиксированы.'"), Строка(ТипДанных));	
КонецПроцедуры

Процедура СообщитьИнформациюПользователю(СтрокаСообщенияПользователю) Экспорт
	
	#Если Клиент Тогда
	Сообщить(СтрокаСообщенияПользователю);
	#КонецЕсли
	
КонецПроцедуры

// Возвращает структуру, содержащую значения реквизитов, прочитанные из информационной базы
// для нескольких объектов.
// 
//  Если доступа к одному из реквизитов нет, возникнет исключение прав доступа.
//  Если необходимо зачитать реквизит независимо от прав текущего пользователя,
//  то следует использовать предварительный переход в привилегированный режим.
// 
// Параметры:
//  МассивСсылок - массив ссылок на объекты одного типа
//				ВАЖНО! значения массива должны быть ссылками на 
//				объекты одного типа!
//  ИменаРеквизитов - Строка, имена реквизитов перечисленные через запятую,
//				в формате требований к свойствам структуры.
//				Например, "Код, Наименование, Родитель".
// 
// Возвращаемое значение:
//  Соответствие, где ключ - ссылка на объект, а Значение - структура, которая 
//				содержит список свойств, как список имен в строке
//				ИменаРеквизитов, со значениям реквизитов, прочитанными
//				из информационной базы.
// 
Функция ЗначенияРеквизитовОбъектов(МассивСсылок, ИменаРеквизитов) Экспорт
	
	ЗначенияРеквизитов = Новый Соответствие;
	Если ТипЗнч(МассивСсылок) = Тип("Массив") ИЛИ ТипЗнч(МассивСсылок) = Тип("ФиксированныйМассив") Тогда
		Если МассивСсылок.Количество() = 0 Тогда
			Возврат ЗначенияРеквизитов;
		КонецЕсли;
	Иначе
		ОбщегоНазначения.СообщитьОбОшибке("Неверный тип параметра ""МассивСсылок""");
	КонецЕсли;
	
	Запрос = Новый Запрос;
	Запрос.Текст =
		"ВЫБРАТЬ
		|	Ссылка КАК Ссылка, " + ИменаРеквизитов + "
		|ИЗ
		|	" + МассивСсылок[0].Метаданные().ПолноеИмя() + " КАК Таблица
		|ГДЕ
		|	Таблица.Ссылка В (&МассивСсылок)";
	Запрос.УстановитьПараметр("МассивСсылок", МассивСсылок);
	
	Выборка = Запрос.Выполнить().Выбрать();
	Пока Выборка.Следующий() Цикл
		Результат = Новый Структура(ИменаРеквизитов);
		ЗаполнитьЗначенияСвойств(Результат, Выборка);
		ЗначенияРеквизитов[Выборка.Ссылка] = Результат;
	КонецЦикла;
	
	Возврат ЗначенияРеквизитов;
	
КонецФункции

// Позволяет определить есть ли среди реквизитов шапки документа
// реквизит с переданным именем.
//
// Параметры: 
//  ИмяРеквизита - строковое имя искомого реквизита, 
//  МетаданныеДокумента - объект описания метаданных документа, среди реквизитов которого производится поиск.
//
// Возвращаемое значение:
//  Истина - нашли реквизит с таким именем, Ложь - не нашли.
//
Функция ЕстьРеквизитДокумента(ИмяРеквизита, МетаданныеДокумента) Экспорт

	Если МетаданныеДокумента.Реквизиты.Найти(ИмяРеквизита) = Неопределено Тогда
		Возврат Ложь;
	Иначе
		Возврат Истина;
	КонецЕсли; 

КонецФункции // ЕстьРеквизитДокумента()

// Позволяет определить есть ли табличная часть документа с переданным именем.
//
// Параметры: 
//  ИмяТабЧасти - строковое имя искомой табличной части,
//  МетаданныеДокумента - объект описания метаданных документа, среди реквизитов которого производится поиск.
//
// Возвращаемое значение:
//  Истина - нашли реквизит с таким именем, Ложь - не нашли.
//
Функция ЕстьТабЧастьДокумента(ИмяТабЧасти, МетаданныеДокумента) Экспорт

	Если МетаданныеДокумента.ТабличныеЧасти.Найти(ИмяТабЧасти) = Неопределено Тогда
		Возврат Ложь;
	Иначе
		Возврат Истина;
	КонецЕсли; 

КонецФункции // ЕстьТабЧастьДокумента()

// Позволяет определить есть ли среди реквизитов шапки отчета
// реквизит с переданным именем.
//
// Параметры: 
//  ИмяРеквизита     - строковое имя искомого реквизита, 
//  МетаданныеОтчета - метаданные отчета, среди реквизитов которого производится поиск.
//
// Возвращаемое значение:
//  Истина - нашли реквизит с таким именем, Ложь - не нашли.
//
Функция ЕстьРеквизитОтчета(ИмяРеквизита, МетаданныеОтчета) Экспорт

	Если МетаданныеОтчета.Реквизиты.Найти(ИмяРеквизита) = Неопределено Тогда
		Возврат Ложь;
	Иначе
		Возврат Истина;
	КонецЕсли; 

КонецФункции // ЕстьРеквизитОтчета()

// Возвращает значение реквизита, прочитанного из информационной базы по ссылке на объект.
// 
//  Если доступа к реквизиту нет, возникнет исключение прав доступа.
//  Если необходимо зачитать реквизит независимо от прав текущего пользователя,
//  то следует использовать предварительный переход в привилегированный режим.
// 
// Параметры:
//  Ссылка       - ссылка на объект, - элемент справочника, документ, ...
//  ИмяРеквизита - Строка, например, "Код".
// 
// Возвращаемое значение:
//  Произвольный    - зависит от типа значения прочитанного реквизита.
// 
Функция ЗначениеРеквизитаОбъекта(Ссылка, ИмяРеквизита) Экспорт
	Возврат ЗначенияРеквизитовОбъекта(Ссылка, ИмяРеквизита)[ИмяРеквизита];	
КонецФункции 

// Возвращает структуру, содержащую значения реквизитов прочитанные из информационной базы
// по ссылке на объект.
// 
//  Если доступа к одному из реквизитов нет, возникнет исключение прав доступа.
//  Если необходимо зачитать реквизит независимо от прав текущего пользователя,
//  то следует использовать предварительный переход в привилегированный режим.
// 
// Параметры:
//  Ссылка    - Ссылка на объект - элемент справочника, документ, ...
//
//  Реквизиты - Строка - имена реквизитов, перечисленные через запятую, в формате
//              требований к свойствам структуры.
//              Например, "Код, Наименование, Родитель".
//            - Структура, ФиксированнаяСтруктура - в качестве ключа передается
//              псевдоним поля для возвращаемой структуры с результатом, а в качестве
//              значения (опционально) фактическое имя поля в таблице.
//              Если значение не определено, то имя поля берется из ключа.
//            - Массив, ФиксированныйМассив - имена реквизитов в формате требований
//              к свойствам структуры.
//
// Возвращаемое значение:
//  Структура - содержит имена (ключи) и значения затребованных реквизитов.
//              Если строка затребованных реквизитов пуста, то возвращается пустая структура
//
Функция ЗначенияРеквизитовОбъекта(Ссылка, Реквизиты) Экспорт
	
	Если ТипЗнч(Реквизиты) = Тип("Строка") Тогда
		Если ПустаяСтрока(Реквизиты) Тогда Возврат Новый Структура; КонецЕсли;
		СтруктураРеквизитов = Новый Структура(Реквизиты);
		
	ИначеЕсли ТипЗнч(Реквизиты) = Тип("Структура") ИЛИ ТипЗнч(Реквизиты) = Тип("ФиксированнаяСтруктура") Тогда
		СтруктураРеквизитов = Реквизиты;

	ИначеЕсли ТипЗнч(Реквизиты) = Тип("Массив") ИЛИ ТипЗнч(Реквизиты) = Тип("ФиксированныйМассив") Тогда
		СтруктураРеквизитов = Новый Структура;
		Для каждого Реквизит Из Реквизиты Цикл
			СтруктураРеквизитов.Вставить(Реквизит);
		КонецЦикла;
	Иначе
		ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(НСтр("ru = 'Неверный тип второго параметра Реквизиты: %1'"), Строка(ТипЗнч(Реквизиты)));
	КонецЕсли;

	ТекстПолей = "";
	Для Каждого КлючИЗначение Из СтруктураРеквизитов Цикл
		ИмяПоля   = ?(ЗначениеЗаполнено(КлючИЗначение.Значение), СокрЛП(КлючИЗначение.Значение), СокрЛП(КлючИЗначение.Ключ));
		Псевдоним = СокрЛП(КлючИЗначение.Ключ);
		ТекстПолей  = ТекстПолей + ?(ПустаяСтрока(ТекстПолей), "", ",") + "
		|	" + ИмяПоля + " КАК " + Псевдоним;
	КонецЦикла;
	
	Запрос=Новый Запрос;
	Запрос.УстановитьПараметр("Ссылка", Ссылка);
	Запрос.Текст =
	"ВЫБРАТЬ
	|" + ТекстПолей + "
	|ИЗ
	|	" + Ссылка.Метаданные().ПолноеИмя() + " КАК ПсевдонимЗаданнойТаблицы
	|ГДЕ
	|	ПсевдонимЗаданнойТаблицы.Ссылка = &Ссылка
	|";
	Выборка = Запрос.Выполнить().Выбрать();
	Выборка.Следующий();
	
	Результат = Новый Структура;
	Для Каждого КлючИЗначение Из СтруктураРеквизитов Цикл
		Результат.Вставить(КлючИЗначение.Ключ);
	КонецЦикла;
	ЗаполнитьЗначенияСвойств(Результат, Выборка);
	
	Возврат Результат;
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ ПРОВЕРКИ НАЛИЧИЯ И ЗАПОЛНЕНИЯ РЕВИЗИТОВ

// Предназначена для получения пустого значения заданного типа:
// примитивного, или ссылочного.
//
// Параметры:
//  ЗаданныйТип   - тип, пустое значение которого нужно получить
//
Функция ПустоеЗначениеТипа(ЗаданныйТип) Экспорт
	
	Если ЗаданныйТип = Тип("Число") Тогда
		Возврат 0;
	ИначеЕсли ЗаданныйТип = Тип("Строка") Тогда
		Возврат "";
	ИначеЕсли ЗаданныйТип = Тип("Дата") Тогда
		Возврат '00010101000000';
	ИначеЕсли ЗаданныйТип = Тип("Булево") Тогда
		Возврат Ложь;
	Иначе
		Возврат Новый (ЗаданныйТип);
	КонецЕсли;
	
КонецФункции

Функция ЗначениеТипаПоУмолчанию(ОписаниеТипа) Экспорт
	Если ОписаниеТипа=Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	Если ОписаниеТипа.Типы().Количество()=1 Тогда
		стрОписаниеТипа=СокрЛП(ОписаниеТипа);
		Если стрОписаниеТипа="Число" Тогда
			Значение=0;
		ИначеЕсли стрОписаниеТипа="Строка" Тогда
			Значение="";
		ИначеЕсли стрОписаниеТипа="Булево" Тогда
			Значение=Ложь;
		ИначеЕсли стрОписаниеТипа="Дата" Тогда
			Значение=Дата(01,01,0001);
		Иначе
			Значение=Новый(ОписаниеТипа.Типы()[0]);
		КонецЕсли;
		Возврат Значение;
	КонецЕсли;
	Возврат Неопределено; 
КонецФункции
 
// Функция проверяет наличие в строке только цифр
//
// Параметры
//  СтрокаПроверки - Строка для проверки только цифр
//
// Возвращаемое значение:
//   Булево
//
Функция ЕстьНеЦифры(Знач СтрокаПроверки) Экспорт

	СписокКодовЧисел = Новый СписокЗначений;
	Для а = 48 По 57 Цикл
		СписокКодовЧисел.Добавить(а);
	КонецЦикла; 
	
	СтрокаПроверки = СокрЛП(СтрокаПроверки);

	Если ТипЗнч(СтрокаПроверки) <> Тип("Строка") Тогда
		Возврат Истина;
	КонецЕсли; 
		
	Для а = 1 По СтрДлина(СтрокаПроверки) Цикл
		Если СписокКодовЧисел.НайтиПоЗначению(КодСимвола(Сред(СтрокаПроверки, а, 1))) = Неопределено Тогда
			Возврат Истина;
		КонецЕсли; 
	КонецЦикла; 

	Возврат Ложь;
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С ТИПАМИ

// Служебная функция, предназначенная для получения описания типов строки, заданной длины.
// 
// Параметры:
//  ДлинаСтроки - число, длина строки.
//
// Возвращаемое значение:
//  Объект "ОписаниеТипов" для строки указанной длины.
//
Функция ПолучитьОписаниеТиповСтроки(ДлинаСтроки) Экспорт
	
	Массив = Новый Массив; 
	Массив.Добавить(Тип("Строка"));
	КвалификаторСтроки = Новый КвалификаторыСтроки(ДлинаСтроки, ДопустимаяДлина.Переменная);
	Возврат Новый ОписаниеТипов(Массив, , КвалификаторСтроки);
	
КонецФункции

// Служебная функция, предназначенная для получения описания типов числа, заданной разрядности.
// 
// Параметры:
//  Разрядность 			- число, разряд числа.
//  РазрядностьДробнойЧасти - число, разряд дробной части.
//  ЗнакЧисла				- ДопустимыйЗнак, знак числа
//
// Возвращаемое значение:
//  Объект "ОписаниеТипов" для числа указанной разрядности.
//
Функция ПолучитьОписаниеТиповЧисла(Разрядность, РазрядностьДробнойЧасти = 0, ЗнакЧисла = Неопределено) Экспорт
	Если ЗнакЧисла = Неопределено Тогда
		КвалификаторЧисла = Новый КвалификаторыЧисла(Разрядность, РазрядностьДробнойЧасти);
	Иначе
		КвалификаторЧисла = Новый КвалификаторыЧисла(Разрядность, РазрядностьДробнойЧасти, ЗнакЧисла);
	КонецЕсли;
	Возврат Новый ОписаниеТипов("Число", КвалификаторЧисла);
КонецФункции

// Служебная функция, предназначенная для получения описания типов даты
// 
// Параметры:
//  ЧастиДаты - системное перечисление ЧастиДаты.
// 
Функция ПолучитьОписаниеТиповДаты(ЧастиДаты) Экспорт
	
	Массив = Новый Массив;
	Массив.Добавить(Тип("Дата"));
	КвалификаторДаты = Новый КвалификаторыДаты(ЧастиДаты);
	Возврат Новый ОписаниеТипов(Массив, , , КвалификаторДаты);
	
КонецФункции

// Служебная функция - возвращает принадлежность объекта метаданных определенному классу
// 
// Параметры:
//  Класс  - класс
//  Объект - объект метаданных
// 
Функция ПринадлежностьКлассуМетаданных(Класс, Объект) Экспорт
	Для Каждого МДОбъект Из Метаданные[Класс] Цикл
		Если МДОбъект = Объект Тогда
			Возврат Истина;
		КонецЕсли;
	КонецЦикла;
	Возврат Ложь;
КонецФункции

// Служебная функция, предназначенная для получения описания типов набора записей по объекту метаданных
// Параметры:
//  Объект - объект метаданных
//
// Возвращаемое значение:
// Описание типов с единственным типом набора записей
//
Функция ПолучитьОписаниеТиповНабораЗаписей(Объект) Экспорт
	Массив=Новый Массив;
	Если ПринадлежностьКлассуМетаданных("РегистрыРасчета", Объект) Тогда
		Массив.Добавить(Тип("РегистрРасчетаНаборЗаписей."+Объект.Имя));
	ИначеЕсли ПринадлежностьКлассуМетаданных("РегистрыБухгалтерии", Объект) Тогда
		Массив.Добавить(Тип("РегистрБухгалтерииНаборЗаписей."+Объект.Имя));
	ИначеЕсли ПринадлежностьКлассуМетаданных("РегистрыНакопления", Объект) Тогда
		Массив.Добавить(Тип("РегистрНакопленияНаборЗаписей."+Объект.Имя));
	ИначеЕсли ПринадлежностьКлассуМетаданных("РегистрыСведений", Объект) Тогда
		Массив.Добавить(Тип("РегистрСведенийНаборЗаписей."+Объект.Имя));
	КонецЕсли;
	Возврат Новый ОписаниеТипов(Массив);	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С ОШИБКАМИ

// Функция убирает из текста сообщения слущебную информацию
//
// Параметры
//  ТекстСообщения, Строка, исходный текст сообщения//
// Возвращаемое значение:
//   Строка
//
Функция СформироватьТекстСообщения(Знач ТекстСообщения) Экспорт

	НачалоСлужебногоСообщения    = Найти(ТекстСообщения, "{");
	ОкончаниеСлужебногоСообщения = Найти(ТекстСообщения, "}:");
	
	Если ОкончаниеСлужебногоСообщения > 0 
		И НачалоСлужебногоСообщения > 0 
		И НачалоСлужебногоСообщения < ОкончаниеСлужебногоСообщения Тогда
		
		ТекстСообщения = Лев(ТекстСообщения, (НачалоСлужебногоСообщения - 1)) +
		                 Сред(ТекстСообщения, (ОкончаниеСлужебногоСообщения + 2));
						 
	КонецЕсли;
	
	Возврат СокрЛП(ТекстСообщения);

КонецФункции

// Выводит сообщение об ошибке и выставляет параметр Отказ в "Истина". 
// В случае работы на клиенте или на сервере выводит в окно сообщений,
// в случае внешнего соединения вызывает исключение.
//
// Параметры:
//  ТекстСообщения - строка, текст сообщения.
//  Отказ          - булево, признак отказа (необязательный).
//
Процедура СообщитьОбОшибке(ТекстСообщения, Отказ = Ложь, Заголовок = "", Статус = Неопределено) Экспорт

	Если Статус = Неопределено Тогда
		Статус = СтатусСообщения.Важное;
	КонецЕсли;
	
	ТекстСообщения = СформироватьТекстСообщения(ТекстСообщения);

	Отказ = Истина;
	
	#Если ВнешнееСоединение Тогда
		
		Если ЗначениеЗаполнено(Заголовок) Тогда
			ТекстСообщения = Заголовок + Символы.ПС + ТекстСообщения;
			Заголовок = "";
		КонецЕсли;
		
		//*** ВызватьИсключение(ТекстСообщения);
		
	#Иначе
		
		Если ЗначениеЗаполнено(Заголовок) Тогда
			Сообщить(Заголовок);
			Заголовок = "";
		КонецЕсли;
		
		Сообщить(ТекстСообщения, Статус);
		
	#КонецЕсли
	
КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С ПЕРЕЧИСЛЕНИЯМИ

// Функция формирует список элементов перечисления
//
// Параметры
//  ИмяПеречисления - имя перечисления, как оно задано в конфигураторе
//
// Возвращаемое значение:
//   СписокЗначений - список элементов перечисления
//
Функция ПолучитьСписокЭлементовПеречисления(ИмяПеречисления) Экспорт

	СписокЭлементовПеречисления = Новый СписокЗначений;

	Попытка КоллекцияЭлементовПеречисления = Перечисления[ИмяПеречисления];
	Исключение Возврат СписокЭлементовПеречисления;
	КонецПопытки;

	Для каждого ЭлементПеречисления Из КоллекцияЭлементовПеречисления Цикл
		СписокЭлементовПеречисления.Добавить(ЭлементПеречисления, Строка(ЭлементПеречисления));
	КонецЦикла;
	
	Возврат СписокЭлементовПеречисления;

КонецФункции

// Предназначена для получения имени элемента перечисления по значению.
//
// Параметры:
//  Элемент перечисления.
//
// Возвращаемое значение:
//  Строка - имя элемента перечисления в метаданных.
//
Функция ПолучитьИмяЭлементаПеречисленияПоЗначению(ЗначениеПеречисления) Экспорт
	
	ИмяЭлемента = Строка(ЗначениеПеречисления);
	Для каждого ЭлементПеречисления Из Метаданные.Перечисления[ЗначениеПеречисления.Метаданные().Имя].ЗначенияПеречисления Цикл
		Если ЭлементПеречисления.Синоним = Строка(ЗначениеПеречисления) Тогда
			ИмяЭлемента = ЭлементПеречисления.Имя;
			Прервать;
		КонецЕсли; 
	КонецЦикла;
	
	Возврат ИмяЭлемента;
	
КонецФункции //УДАЛИТЬ!

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С МЕТАДАННЫМИ

// Процедура предназначена для получения момента определения остатков для заполнения документа.
//
// Параметры:
//  ДокОбъект - (ДокументОбъект), документ, для которого надо определить дату получения остатков.
//
// Возвращаемое значение.
//  Дата (момент времени) - дата остатков
//
Функция ПолучитьДатуОстатков(ДокОбъект, ЗапретитьПустуюДату=Ложь) Экспорт
	
	ДатаОстатков = '00010101'; //Пустая дата
	Если НачалоДня(ДокОбъект.Дата) <> НачалоДня(ТекущаяДата()) Тогда
		ЗапретитьПустуюДату=Истина;
	КонецЕсли;

	Если ЗапретитьПустуюДату И ДокОбъект.Дата <> '00010101' Тогда
		Если НЕ ЗначениеЗаполнено(ДокОбъект.Ссылка) Тогда
			ДатаОстатков = КонецДня(ДокОбъект.Дата);
		Иначе
			ДатаОстатков = ДокОбъект.МоментВремени();
		КонецЕсли;
	КонецЕсли;

	Возврат ДатаОстатков;
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С ДВИЖЕНИЯМИ ДОКУМЕНТОВ

Процедура ОчиститьДвиженияРегистраПоРегистратору(ДокументСсылка, стрРегистр) Экспорт
	//*** Если ДокументСсылка.Пустая() Тогда Возврат; КонецЕсли;
	НаборЗаписей=РегистрыНакопления[стрРегистр].СоздатьНаборЗаписей();
	НаборЗаписей.Отбор.Регистратор.Установить(ДокументСсылка);
	НаборЗаписей.Прочитать();
	Если НаборЗаписей.Количество()>0 Тогда
		НаборЗаписей.Очистить();
		НаборЗаписей.Записать();
	КонецЕсли;
КонецПроцедуры

Функция ПолучитьМассивРегистровДляПроведения(ДокументОбъект) Экспорт
	МассивРегистров=Неопределено;
	Если ДокументОбъект.ДополнительныеСвойства.Свойство("РегистрыДляПроведения") Тогда;
		МассивРегистров=Новый Массив;
		Для каждого СтрокаКоллекции Из ДокументОбъект.ДополнительныеСвойства.РегистрыДляПроведения Цикл
			Если СтрокаКоллекции="УчетВнеоборотныхАктивов" Тогда
				МассивРегистров.Добавить("УчетВнеоборотныхАктивовНМА");
				МассивРегистров.Добавить("УчетВнеоборотныхАктивовОС");
			ИначеЕсли СтрокаКоллекции="УчетВзаиморасчетов" Тогда
				МассивРегистров.Добавить("ВзаиморасчетыСКонтрагентами");
				МассивРегистров.Добавить("ВзаиморасчетыСПодотчетнымиЛицами");
			ИначеЕсли СтрокаКоллекции="УчетДенежныхСведств" Тогда
				МассивРегистров.Добавить("ДвиженияДенежныхСредств");
				МассивРегистров.Добавить("ДенежныеСредства");
			ИначеЕсли СтрокаКоллекции="УчетНДС" Тогда
				МассивРегистров.Добавить("НДСВключенныйВСтоимость");
				МассивРегистров.Добавить("НДСЗаписиКнигиПокупок");
				МассивРегистров.Добавить("НДСЗаписиКнигиПродаж");
				МассивРегистров.Добавить("НДСКосвенныеРасходы");
				МассивРегистров.Добавить("НДСНачисленный");
				МассивРегистров.Добавить("НДСПартииТоваров");
				МассивРегистров.Добавить("НДСПредъявленный");
				МассивРегистров.Добавить("НДСПредъявленныйРеализация0");
				МассивРегистров.Добавить("НДСРасчетыСПокупателями");
				МассивРегистров.Добавить("НДСРасчетыСПоставщиками");
				МассивРегистров.Добавить("НДСРеализация0");
				МассивРегистров.Добавить("НДСсАвансов");
			Иначе
				МассивРегистров.Добавить(СтрокаКоллекции);			
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	Возврат МассивРегистров;	
КонецФункции

Процедура УдалитьДвиженияРегистратора(ДокументОбъект, Отказ) Экспорт
	мдОбъект=ДокументОбъект.Метаданные();
	Если СокрЛП(мдОбъект.ЗаписьДвиженийПриПроведении)="ЗаписыватьВыбранные" Тогда Возврат; КонецЕсли; //***
		
	ДокументСсылка=ДокументОбъект.Ссылка;
	МассивРегистров=ПолучитьМассивРегистровДляПроведения(ДокументОбъект);
	ОбъектДвижения=ДокументОбъект.Движения;

	Для Каждого мдРегистр Из мдОбъект.Движения Цикл
		стрТипВидРегистра=мдРегистр.ПолноеИмя();

		ПозицияТочки=Найти(стрТипВидРегистра, ".");
		ТипРегистра=Лев(стрТипВидРегистра, ПозицияТочки-1);
		ИмяРегистра=СокрП(Сред(стрТипВидРегистра, ПозицияТочки+1));

		Если Не МассивРегистров=Неопределено Тогда
			Если МассивРегистров.Найти(ИмяРегистра)=Неопределено Тогда
				Продолжить;
			КонецЕсли;
		КонецЕсли;

		ЕСли ТипРегистра="РегистрНакопления" Тогда
			Набор=РегистрыНакопления[ИмяРегистра].СоздатьНаборЗаписей();
			Набор.Отбор.Регистратор.Установить(ДокументСсылка);
		ИначеЕсли ТипРегистра="РегистрСведений" Тогда
			Набор=РегистрыСведений[ИмяРегистра].СоздатьНаборЗаписей();  			
			Набор.Отбор.Регистратор.Установить(ДокументСсылка);
		ИначеЕсли ТипРегистра="РегистрБухгалтерии" Тогда
			Набор=РегистрыБухгалтерии[ИмяРегистра].СоздатьНаборЗаписей();
			Набор.Отбор.Регистратор.Установить(ДокументСсылка);
		КонецЕсли;
		Набор.Прочитать();
		Если Набор.Количество()=0 Тогда Продолжить; КонецЕсли;
		Набор.Очистить();
		Набор.Записать();

		Движение=ОбъектДвижения[мдРегистр.Имя];
		Если Движение.Количество()>0 Тогда
			Движение.Очистить();
		КонецЕсли;
	КонецЦикла;
КонецПроцедуры

// Добавляет в таблицу значений строки из другой таблицы значений и 
// в них значения колонок с совпадающими наименованиями.
//
// Параметры:
//  ТаблицаИсточник - таблица значений, откуда берутся значения.
//  ТаблицаПриемник - таблица значений, куда добавляются строки.
//
Процедура ЗагрузитьВТаблицуЗначений(ТаблицаИсточник, ТаблицаПриемник) Экспорт

	// Заполним значения в совпадающих колонках.
	Для каждого СтрокаТаблицыИсточника Из ТаблицаИсточник Цикл
		СтрокаТаблицыПриемника = ТаблицаПриемник.Добавить();
		ЗаполнитьЗначенияСвойств(СтрокаТаблицыПриемника, СтрокаТаблицыИсточника);
	КонецЦикла;

КонецПроцедуры

// Проверяет наличие требуемых данных в источнике и Формирует таблицу значений
//
// Параметры
//  Источник  – ТаблицаЗначений или ТабличнаяЧасть или КоллекцияСтрокДереваЗначений с исходными данными
//
//  Реквизиты – структура – Структура реквизитов. 
//             Ключ     - Наименование колонки в источнике
//             Значение - Наименование колонки в получаемой ТЗ, если значение опущено - приравнивается ключу.
//  ПолучитьНомерСтрокиДокумента - булево
//                                 Используется только при выгрузке из табличной части документа.
//                                 В формируемой таблице создает новую колонку "НомерСтрокиДокумента"
//                                 и заполняет её реальными номерами строк
//
//  КоллекцияКолонокДереваЗначений - только для коллекции строк дерева значений.
//
// Возвращаемое значение:
//  Таблица значений или Неопределено (если не хватает реквизитов)
//
Функция СформироватьТаблицуЗначений(Источник,Реквизиты=Неопределено,ПолучитьНомерСтрокиДокумента = ложь,ФормироватьОтстутствующиеКолонки=Ложь,КоллекцияКолонокДереваЗначений=Неопределено) экспорт

	ЭтоТаблицаЗначений=(ТипЗнч(Источник)= тип("ТаблицаЗначений"));
	ЭтоСтрокиДереваЗначений=(ТипЗнч(Источник)= тип("КоллекцияСтрокДереваЗначений"));
	Если ЭтоСтрокиДереваЗначений и КоллекцияКолонокДереваЗначений = Неопределено тогда
		Возврат Неопределено;
	Конецесли;
	
	Если НЕ ЗначениеЗаполнено(Реквизиты) тогда
		Если ЭтоТаблицаЗначений тогда
			НоваяТЗ = Источник.Скопировать();
	  		Возврат НоваяТЗ;
		ИначеЕсли ЭтоСтрокиДереваЗначений тогда
			Реквизиты = Новый Структура();
			Для каждого Колонка из КоллекцияКолонокДереваЗначений цикл
				Реквизиты.Вставить(Колонка.Имя);
			КонецЦикла;
		Иначе
			НоваяТЗ = Источник.Выгрузить();
	  		Возврат НоваяТЗ;
		КонецЕслИ;
	Конецесли;
	
	Если не ЭтоТаблицаЗначений  и не ЭтоСтрокиДереваЗначений тогда
		РеквизитыТабличнойЧасти = Метаданные.НайтиПоТипу(ТипЗнч(Источник)).Реквизиты;
	Конецесли;
	
	НоваяТЗ= Новый ТаблицаЗначений();
	
	Если не ЭтоТаблицаЗначений и ПолучитьНомерСтрокиДокумента тогда
 		НоваяТЗ.Колонки.Добавить("НомерСтрокиДокумента",ПолучитьОписаниеТиповЧисла(5,0));
	КонецЕсли;

	Пока НоваяТЗ.Количество()<Источник.Количество() Цикл
		Строка = НоваяТЗ.Добавить();
		Если не ЭтоТаблицаЗначений и ПолучитьНомерСтрокиДокумента тогда
			Строка.НомерСтрокиДокумента = НоваяТЗ.Количество();
		КонецЕсли;
	КонецЦикла;
	
	Для каждого ТекРеквизит из Реквизиты Цикл
		ИскомыйРеквизит = ТекРеквизит.Ключ;
		НовыйРеквизит 	= ?(ТекРеквизит.Значение = Неопределено,ТекРеквизит.Ключ,ТекРеквизит.Значение);
		Если ЭтоТаблицаЗначений тогда
			ИсточникКолонка = Источник.Колонки.Найти(ИскомыйРеквизит);
		ИначеЕсли ЭтоСтрокиДереваЗначений тогда
			ИсточникКолонка = КоллекцияКолонокДереваЗначений.Найти(ИскомыйРеквизит);
		Иначе
			ИсточникКолонка = РеквизитыТабличнойЧасти.Найти(ИскомыйРеквизит);
		Конецесли;
		Если ИсточникКолонка= неопределено тогда
			//недостаточно реквизитов
			Если ФормироватьОтстутствующиеКолонки тогда
				НоваяТЗ.Колонки.Добавить(НовыйРеквизит);
			Иначе
				Возврат Неопределено;
			КонецЕсли;	
		Иначе
			НоваяТЗ.Колонки.Добавить(НовыйРеквизит);
			НоваяТЗ.ЗагрузитьКолонку(Источник.ВыгрузитьКолонку(ИскомыйРеквизит),НовыйРеквизит);
		Конецесли;
	КонецЦикла;
	
    Возврат НоваяТЗ;
КонецФункции

// Формирует структуру, содержащую значения реквизитов шапки документа.
//
// Параметры: 
//  ДокументОбъект - объект документа для формирования структуры шапки, 
//
// Возвращаемое значение:
//  Сформированная структура.
//
Функция СформироватьСтруктуруШапкиДокумента(ДокументОбъект) Экспорт
	СтруктураШД=Новый Структура;
	СтруктураШД.Вставить("Ссылка", ДокументОбъект.Ссылка);
	СтруктураШД.Вставить("МоментВремени", ДокументОбъект.МоментВремени());
	СтруктураШД.Вставить("Дата", ДокументОбъект.Дата);
	СтруктураШД.Вставить("Номер", ДокументОбъект.Номер);
	СтруктураШД.Вставить("ВидДокумента",  ДокументОбъект.Метаданные().Имя);
	СтруктураШД.Вставить("ВалютаРегламентированногоУчета", МодульВалютногоУчета.ПолучитьВалюту("Бух"));

	Для Каждого мдРеквизит Из Метаданные.Документы[СтруктураШД.ВидДокумента].Реквизиты Цикл
		СтруктураШД.Вставить(мдРеквизит.Имя, ДокументОбъект[мдРеквизит.Имя]);
	КонецЦикла;
	
	Организация=Неопределено; СтруктураШД.Свойство("Организация", Организация);

	Попытка УчетнаяПолитика=ДокументОбъект.ПараметрыУчетнойПолитики();
	Исключение УчетнаяПолитика=ПолучитьПараметрыУчетнойПолитики(ДокументОбъект.Дата, Ложь, Организация,,Ложь);
	КонецПопытки;

	СтруктураШД.Вставить("УчетнаяПолитика", УчетнаяПолитика);
	СтруктураШД.Вставить("ОрганизацияПрименяетУСН", ?(Организация<>Неопределено, ПрименениеУСН(Организация, СтруктураШД.Дата, УчетнаяПолитика), Ложь));
    СтруктураШД.Вставить("ОрганизацияНеЯвляетсяПлательщикомНДС", УчетнаяПолитика.ОрганизацияНеЯвляетсяПлательщикомНДС);
	СтруктураШД.Вставить("ПрименениеПБУ18", УчетнаяПолитика.ПоддержкаПБУ18);

	Если Организация<>Неопределено Тогда
		СтруктураШД.Вставить("Префикс", Организация.Префикс);		
	КонецЕсли; 
	
	Возврат СтруктураШД;
КонецФункции

Функция СформироватьЗапросПоТабличнойЧасти(ДокументОбъект, ИмяТабличнойЧасти, СтруктураПолей) Экспорт

	ТекстЗапроса = "";
	Для Каждого Реквизит Из СтруктураПолей Цикл
		ТекстЗапроса=ТекстЗапроса+",Док."+Реквизит.Значение+" КАК "+СокрЛП(Реквизит.Ключ);
	КонецЦикла;

	Запрос=Новый Запрос;
	Запрос.УстановитьПараметр("ДокументСсылка" , ДокументОбъект.Ссылка);
	Запрос.Текст = "
	|ВЫБРАТЬ 
	|	Док.НомерСтроки " + ТекстЗапроса + "
	|ИЗ 
	|	Документ." + ДокументОбъект.Метаданные().Имя + "."+ СокрЛП(ИмяТабличнойЧасти) + " КАК Док
	|ГДЕ
	|	Док.Ссылка = &ДокументСсылка
	|";
	Возврат Запрос.Выполнить();
КонецФункции

Процедура ВыполнитьДвижениеПоРегистру(НаборДвижений, ВидДвижения = Неопределено, ПустыеКолонкиСоставногоТипа = Неопределено, ЗаполнитьПериод = истина) Экспорт

	ТаблицаДвижений=НаборДвижений.мТаблицаДвижений;
	Если ТаблицаДвижений.Количество()=0 Тогда Возврат; КонецЕсли;

	Если ПустыеКолонкиСоставногоТипа = Неопределено Тогда
		ПустыеКолонкиСоставногоТипа = Новый Структура;
	КонецЕсли;
	
	МетаРег = НаборДвижений.Метаданные();
	ИзмеренияСостТипа = Новый Структура;
	Для Каждого МетаИзм Из МетаРег.Измерения Цикл
		Если (МетаИзм.Тип.Типы().Количество() > 1) И НЕ (ПустыеКолонкиСоставногоТипа.Свойство(МетаИзм.Имя)) Тогда
			ИзмеренияСостТипа.Вставить(МетаИзм.Имя);
		КонецЕсли;
	КонецЦикла;
	Для Каждого МетаРек Из МетаРег.Реквизиты Цикл
		Если (МетаРек.Тип.Типы().Количество() > 1) И НЕ (ПустыеКолонкиСоставногоТипа.Свойство(МетаРек.Имя)) Тогда
			ИзмеренияСостТипа.Вставить(МетаРек.Имя);
		КонецЕсли;
	КонецЦикла;
	Для Каждого МетаРес Из МетаРег.Ресурсы Цикл
		Если (МетаРес.Тип.Типы().Количество() > 1) И НЕ (ПустыеКолонкиСоставногоТипа.Свойство(МетаРес.Имя)) Тогда
			ИзмеренияСостТипа.Вставить(МетаРес.Имя);
		КонецЕсли;
	КонецЦикла;

	// Откопируем остальные колонки (структура таблиц совпадает).
	ПерваяКолонка = Истина;
	МассивСтрок   = Новый Массив(ТаблицаДвижений.Количество());
	ЕстьПериод    = НЕ ТаблицаДвижений.Колонки.Найти("Период") = Неопределено;
	Для каждого Колонка Из ТаблицаДвижений.Колонки Цикл

		ИмяКолонки = Колонка.Имя;
		Если ИмяКолонки <> "Период"
		   И ИмяКолонки <> "Активность"
		   И ИмяКолонки <> "НомерСтроки"
		   И ИмяКолонки <> ""
		   И ?(ИмяКолонки = "ВидДвижения", ВидДвижения = Неопределено, Истина)
		   И ИмяКолонки <> "МоментВремени" Тогда
		   
			Если ИзмеренияСостТипа.Свойство(ИмяКолонки) Тогда
				ФлагКолонкиСостТипа = Истина;
			Иначе
				ФлагКолонкиСостТипа = Ложь;
			КонецЕсли;
			
			Индекс = 0;
			Для каждого СтрокаТаблицы Из ТаблицаДвижений Цикл

				Если ПерваяКолонка Тогда
					
					Если ВидДвижения = ВидДвиженияНакопления.Приход Тогда
						СтрокаДвижения = НаборДвижений.ДобавитьПриход();
					ИначеЕсли ВидДвижения = ВидДвиженияНакопления.Расход Тогда
						СтрокаДвижения = НаборДвижений.ДобавитьРасход();
					Иначе
						СтрокаДвижения = НаборДвижений.Добавить(); // Для оборотных регистров
					КонецЕсли;
					
					МассивСтрок[Индекс] = СтрокаДвижения;
					СтрокаДвижения.Период = НаборДвижений.мПериод;
					Если не ЗаполнитьПериод и ЕстьПериод И НЕ СтрокаТаблицы.Период = '00010101' Тогда
						СтрокаДвижения.Период = СтрокаТаблицы.Период;
					Иначе
						СтрокаДвижения.Период = НаборДвижений.мПериод;
					КонецЕсли;
				Иначе
					СтрокаДвижения = МассивСтрок[Индекс];
				КонецЕсли;
				
				Индекс = Индекс + 1;
				
				ЗначКолонки = СтрокаТаблицы[ИмяКолонки];
				Если ФлагКолонкиСостТипа Тогда

					Очистить = Ложь;
					Если ТипЗнч(ЗначКолонки) = Тип("Число")Тогда
						Если ЗначКолонки = 0 Тогда Очистить = Истина; КонецЕсли;

					ИначеЕсли ТипЗнч(ЗначКолонки) = Тип("Строка") Тогда
						Если ЗначКолонки = "" Тогда Очистить = Истина; КонецЕсли;

					ИначеЕсли ТипЗнч(ЗначКолонки) = Тип("Дата") Тогда
						Если ЗначКолонки = '00010101000000' Тогда Очистить = Истина; КонецЕсли;

					ИначеЕсли ЗначКолонки = Неопределено Или ЗначКолонки.Пустая() Тогда
						Очистить = Истина;
					КонецЕсли;

					Если Очистить Тогда
						СтрокаДвижения[ИмяКолонки] = Неопределено;
					Иначе
						СтрокаДвижения[ИмяКолонки] = ЗначКолонки;
					КонецЕсли;
				Иначе
					СтрокаДвижения[ИмяКолонки] = ЗначКолонки;
				КонецЕсли;
				
			КонецЦикла;
			
			ПерваяКолонка = Ложь;
			
		КонецЕсли;

	КонецЦикла;

КонецПроцедуры

// Получить движение(набор записей) для документа-объекта
//
// Параметры
//  Объект  – 	ДокументОбъект – Документ. для которого производится поиск движения
//  ТипДвижения  – Регистр<...>Менеджер – менеджер регистра, движение по которому пытаемся сформировать
//                 
// Возвращаемое значение:
//   Регистр<...>НаборЗаписей   – набор записей для объекта
//
Функция ПолучитьДвижение(Объект, ТипДвижения, Сообщать=Ложь) Экспорт
	Движение = неопределено;
	Для каждого ТекДвижение из Объект.Движения цикл
		Если ТипЗнч(ТипДвижения.СоздатьНаборЗаписей()) = ТипЗнч(ТекДвижение) тогда
			Движение=ТекДвижение; Прервать;
		КонецЕсли;
	КонецЦикла;
	
	Если Сообщать и Движение = неопределено тогда
		СообщитьОбОшибке("Требуется подключение """+ТипЗНЧ(Объект)+""" к формированиям движения по регистру """+ТипЗнч(ТипДвижения)+"""!");
	КонецЕсли;
	Возврат Движение;
КонецФункции

// Получить набор записей по регистру по ссылке на документ
//
// Параметры
//  Ссылка  		– ДокументСсылка		– Ссылка на документ, для которого производится поиск движений по регистру (набора записей)
//  РегистрДвижения – Регистр<...>Менеджер	– менеджер регистра, движение по которому пытаемся обнаружить
//  ПрочитатьЗаписи - Булево 				- Прочитать существующий набор записей для документа (если документ может формировать движения по указанному регистру).
//                 
// Возвращаемое значение:
//   Регистр<...>НаборЗаписей – Набор записей по регистру с отбором по документу,
//	 Неопределено 				в случае если документ не может формировать движений по регистру.
//
Функция ПолучитьНаборЗаписейПоСсылке(Ссылка, РегистрДвижения, ПрочитатьЗаписи = Ложь, Сообщать=Ложь) Экспорт
	Движения = неопределено;
	Если Ссылка.Метаданные().Движения.Содержит(Метаданные.НайтиПоТипу(ТипЗнч(РегистрДвижения))) тогда
        Движения = РегистрДвижения.СоздатьНаборЗаписей();
		Движения.Отбор.Регистратор.Установить(Ссылка);
		Если ПрочитатьЗаписи тогда
			Движения.Прочитать();
		КонецЕсли;
	ИначеЕсли Сообщать тогда
		СообщитьОбОшибке("Требуется подключение документа """+Метаданные.НайтиПоТипу(ТипЗнч(Ссылка)).Представление()+""" к формированию движений по регистру """+
		СтрЗаменить(Лев(Строка(ТипЗнч(РегистрДвижения)),Найти(Строка(ТипЗнч(РегистрДвижения)),":"))," менеджер","")+Сред(Строка(ТипЗнч(РегистрДвижения)),Найти(Строка(ТипЗнч(РегистрДвижения)),":")+1)+"""!");
	КонецЕсли;
	
	Возврат Движения;
КонецФункции

// Процедура удаляет строки с пустыми значениями из структуры таблиц документа
//	Параметры:
//		- ТаблицыДляДвиженийПоЗаказам - структура таблиц документа
//		- ИмяПоля - имя поля, значение которого проверяет на пустое значение.
//
Процедура УдалитьСтрокиИзТаблицДокумента(ТаблицыДляДвиженийПоЗаказам, ИмяПоля) Экспорт

	Для Каждого ТабЧасть Из ТаблицыДляДвиженийПоЗаказам Цикл
		КолвоСтрок = ТабЧасть.Значение.Количество();
		Для Инд = 1 По КолвоСтрок Цикл
			ТекСтрока = ТабЧасть.Значение[КолвоСтрок - Инд];

			Если НЕ ЗначениеЗаполнено(ТекСтрока[ИмяПоля]) Тогда
				ТабЧасть.Значение.Удалить(ТекСтрока);
			КонецЕсли;
		КонецЦикла;
	КонецЦикла;

КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ ПРОЧИХ ПОДСИСТЕМ, НЕ ИМЕЮЩИХ СВОИХ ОБЩИХ МОДУЛЕЙ

// Стандартная для данной конфигурации функция форматирования сумм
//
// Параметры: 
//  Сумма  - число, которое мы хотим форматировать, 
//  Валюта - ссылка на элемент справочника валют, если задан, то к в результирующую строку
//           будет добавлено представление валюты
//  ЧН     - строка, представляющая нулевое значение числа,
//  ЧРГ    - символ-разделитель групп целой части числа.
//
// Возвращаемое значение:
//  Отформатированная должным образом строковое представление суммы.
//
Функция ФорматСумм(Сумма, Валюта = Неопределено, ЧН = "", ЧРГ = "") Экспорт

	ФорматнаяСтрока = "ЧЦ=15;ЧДЦ=2" +
					?(НЕ ЗначениеЗаполнено(ЧН), "", ";" + "ЧН=" + ЧН) +
					?(НЕ ЗначениеЗаполнено(ЧРГ),"", ";" + "ЧРГ=" + ЧРГ);
	РезультирующаяСтрока = СокрЛ(Формат(Сумма, ФорматнаяСтрока));
	
	Если ЗначениеЗаполнено(Валюта) Тогда
		РезультирующаяСтрока = РезультирующаяСтрока + " " + СокрП(Валюта);
	КонецЕсли;

	Возврат РезультирующаяСтрока;

КонецФункции

Функция ПолучитьРабочуюДату() Экспорт

#Если Клиент Тогда
	Дата = РабочаяДата;
#Иначе
	Дата = ТекущаяДата();
#КонецЕсли

	Возврат Дата;

КонецФункции

// Возвращает строку, описывающую период, определяемый переданными
// датой и периодичностью.
//
// Параметры
//  ДатаВПериоде:Дата - дата из периода
//  Периодичность: Строка - строка, определяющая периодичность
//
// Возвращаемое значение:
//   СтрокаПериод: строка   – представление периода для вывода в отчетах
//
Функция ПолучитьПериодСтрокой(ДатаВПериоде,Периодичность) Экспорт

	Если Периодичность = "Год" Тогда
		ФорматДаты = "ДФ = ""гггг """"г.""""""";
	ИначеЕсли Периодичность = "Квартал" Тогда
		ФорматДаты = "ДФ = ""к"""" квартал"""" гггг """"г.""""""";
	ИначеЕсли Периодичность = "Месяц" Тогда
		ФорматДаты = "ДФ = ""ММММ гггг """"г.""""""";
	ИначеЕсли Периодичность = "Неделя" Тогда
		ФорматДаты = "ДФ = """"""Неделя с"""" дд.ММ.гггг """"""";
	ИначеЕсли Периодичность = "День" Тогда
		ФорматДаты = "ДФ = ""дд.ММ.гггг """"г.""""""";
	Иначе
		ФорматДаты = "";
	КонецЕсли;

	СтрокаПериод = "" + Формат(ДатаВПериоде, ФорматДаты);
	Если Периодичность = "Неделя" И ТипЗнч(ДатаВПериоде) = Тип("Дата") Тогда
		СтрокаПериод = СтрокаПериод + Формат(КонецНедели(ДатаВПериоде), "ДФ = """""" по """" дд.ММ.гггг """"г.""""""");
	КонецЕсли;
	
	Возврат СтрокаПериод;
	
КонецФункции

// Процедура формирует движения в регистры по прочим затратам по управленческому учету
//
//Параметры:
//		ДокСсылка - ссылка на документ
//		ТабЧасть  - таб. часть по которой формируются движения
//			В ней обязательно должны быть реквизиты "СтатьяЗатрат", "Сумма"
//			"Заказ", "Подразделение",
//			"НоменклатурнаяГруппа"
//		СтруктВал - структура с информацией о валюте
//		ВалютаРегламентированногоУчета - валюта регламентированного учета
//		ДопПараметры - структура с доп. параметрами. Возможные значения
//			"ЕстьНДС" - признак наличия НДС в документе
//
Процедура ДвиженияПоПрочимЗатратамУпр(ДокОбъект, ТабЧасть, СтруктураШапкиДокумента, ВалютаРегламентированногоУчета, ДопПараметры = Неопределено) Экспорт

	НаборДвиженийЗатраты   = ДокОбъект.Движения.Затраты;
	ТаблицаДвиженийЗатраты = НаборДвиженийЗатраты.ВыгрузитьКолонки();

	ЕстьВалютаДокумента = СтруктураШапкиДокумента.Свойство("ВалютаДокумента");
	ЕстьКурсДокумента = Ложь;
	ЕстьНДС = Ложь;
	
	// Определим доп. параметры
	Организация		= Неопределено;
	Контрагент		= Неопределено;
	ДокСтатьяЗатрат = Неопределено;
	ДокЗаказ        = Неопределено;
	ДокПодразделение= Неопределено;
	ИмяРеквЗаказ    = "Заказ";
	
	Если Не ДопПараметры = Неопределено Тогда
		Если ДопПараметры.Свойство("Организация") Тогда
			Организация = ДопПараметры["Организация"];
			Если Организация = Неопределено Тогда
				Организация = Справочники.Организации.ПустаяСсылка();
			КонецЕсли;
		КонецЕсли; 
		
		Если ДопПараметры.Свойство("Контрагент") Тогда
			Контрагент = ДопПараметры["Контрагент"];
			Если Контрагент = Неопределено Тогда
				Контрагент = Справочники.Контрагенты.ПустаяСсылка();
			КонецЕсли;
		КонецЕсли;

		Если ДопПараметры.Свойство("ЕстьНДС") Тогда
			ЕстьНДС = ДопПараметры["ЕстьНДС"];
		КонецЕсли;
		
		Если ДопПараметры.Свойство("СтатьяЗатрат") Тогда
			ДокСтатьяЗатрат = ДопПараметры["СтатьяЗатрат"];
		КонецЕсли;
		
		Если ДопПараметры.Свойство("Заказ") Тогда
			ДокЗаказ = ДопПараметры["Заказ"];
			Если ДокЗаказ = Неопределено Тогда
				ДокЗаказ = Документы.ЗаказПокупателя.ПустаяСсылка();
			КонецЕсли;
		КонецЕсли;
		
		Если ДопПараметры.Свойство("Подразделение") Тогда
			ДокПодразделение = ДопПараметры["Подразделение"];
		КонецЕсли;
		
		Если ДопПараметры.Свойство("ИмяРеквЗаказ") Тогда
			ИмяРеквЗаказ = ДопПараметры["ИмяРеквЗаказ"];
		КонецЕсли;

		Если ДопПараметры.Свойство("КурсДокумента") Тогда
			КурсДок = ДопПараметры["КурсДокумента"];
			ЕстьКурсДокумента = Истина;
		КонецЕсли;
		
		Если ДопПараметры.Свойство("КратностьДокумента") Тогда
			КратДок = ДопПараметры["КратностьДокумента"];
		КонецЕсли;
	КонецЕсли;

	Если ЕстьВалютаДокумента И НЕ ЕстьКурсДокумента Тогда
		КратДок = ЗаполнениеДокументов.КратностьДокумента(ДокОбъект, ВалютаРегламентированногоУчета);
		КурсДок = ЗаполнениеДокументов.КурсДокумента     (ДокОбъект, ВалютаРегламентированногоУчета);
	КонецЕсли;
	
	ТабличнаяЧасть=?(ТипЗнч(ТабЧасть)=Тип("ТаблицаЗначений"), ТабЧасть, ТабЧасть.Выгрузить());

	УчетнаяПолитика=ДокОбъект.ДополнительныеСвойства.УчетнаяПолитика;
	//**** УчетнаяПолитика=ПолучитьПараметрыУчетнойПолитики(ДокОбъект.Дата, Ложь, Организация);
	НеВключатьНДСВСтоимость=?(УчетнаяПолитика.Количество()=0, Ложь, УчетнаяПолитика.НеВключатьНДСВЗатраты);

	ЕстьФизЛицо	 = ?(ТабличнаяЧасть.Колонки.Найти("ФизЛицо") 	  = Неопределено, Ложь, Истина); 
	ЕстьТовар	 = ?(ТабличнаяЧасть.Колонки.Найти("Номенклатура") = Неопределено, Ложь, Истина); 
	ЕстьКолво    = ?(ТабличнаяЧасть.Колонки.Найти("Количество")   = Неопределено, Ложь, Истина); 
	ЕстьСуммаУпр = ?(ТабличнаяЧасть.Колонки.Найти("СуммаУпр")     = Неопределено, Ложь, Истина); 
	ЕстьНДСУпр   = ?(ТабличнаяЧасть.Колонки.Найти("НДСУпр")       = Неопределено, Ложь, Истина); 
	
	// Обход табличной части
	Для Каждого СтрокаТЧ Из ТабЧасть Цикл
		СтатьяЗатрат = ?(ДокСтатьяЗатрат = Неопределено, СтрокаТЧ.СтатьяЗатрат,  ДокСтатьяЗатрат);
		Заказ        = ?(ДокЗаказ        = Неопределено, СтрокаТЧ[ИмяРеквЗаказ], ДокЗаказ);
		ЦФО          = ?(ДокПодразделение= Неопределено, СтрокаТЧ.Подразделение, ДокПодразделение);

		Если ЕстьСуммаУпр Тогда
			СуммаУпр = СтрокаТЧ.СуммаУпр;
			Если ЕстьНДСУпр И НеВключатьНДСВСтоимость Тогда
				СуммаУпр = СуммаУпр - СтрокаТЧ.НДСУпр;
			КонецЕсли;
			
		ИначеЕсли ЕстьВалютаДокумента Тогда
			Если НеВключатьНДСВСтоимость Тогда
				Стоимость = СтрокаТЧ.Сумма;
			Иначе
				Стоимость = СтрокаТЧ.Сумма + ?(ЕстьНДС, СтрокаТЧ.НДС, 0);
			КонецЕсли;
		
			СуммаУпр = ПересчитатьИзВалютыВВалюту(Стоимость, СтруктураШапкиДокумента.ВалютаДокумента,
				 СтруктураШапкиДокумента.ВалютаУправленческогоУчета,     КурсДок, 
				 СтруктураШапкиДокумента.КурсВалютыУправленческогоУчета, КратДок, 
				 СтруктураШапкиДокумента.КратностьВалютыУправленческогоУчета);
		Иначе
			СуммаУпр = СтрокаТЧ.Сумма + ?(ЕстьНДС, СтрокаТЧ.СуммаНДС, 0);
		КонецЕсли;

		Если СуммаУпр = 0 Тогда Продолжить; КонецЕсли;

		НоваяСтрока=ТаблицаДвиженийЗатраты.Добавить();
		НоваяСтрока.Организация			 = Организация;
		НоваяСтрока.Контрагент			 = Контрагент;
		НоваяСтрока.Номенклатура	     = ?(ЕстьТовар, СтрокаТЧ.Номенклатура, Справочники.Номенклатура.ПустаяСсылка());
		НоваяСтрока.Подразделение        = ЦФО;
		НоваяСтрока.СтатьяЗатрат         = СтатьяЗатрат;
		НоваяСтрока.НоменклатурнаяГруппа = СтрокаТЧ.НоменклатурнаяГруппа;
		НоваяСтрока.Заказ                = Заказ;
		НоваяСтрока.Сумма                = СуммаУпр;
		НоваяСтрока.Количество			 = ?(ЕстьКолво, СтрокаТЧ.Количество, 0);
		НоваяСтрока.СуммаНДС			 = ?(ЕстьНДСУпр, СтрокаТЧ.НДСУпр, 0);
		Если ЕстьФизЛицо Тогда
			НоваяСтрока.ФизЛицо=СтрокаТЧ.ФизЛицо;
		КонецЕсли;
	КонецЦикла;

	//13.12.11
	ТаблицаДвиженийЗатраты.ЗаполнитьЗначения(Истина, "Активность");
	ТаблицаДвиженийЗатраты.ЗаполнитьЗначения(ДокОбъект.Дата, "Период");
	НаборДвиженийЗатраты.Загрузить(ТаблицаДвиженийЗатраты);
	
	// Записать движения
	////НаборДвиженийЗатраты.мПериод          = ДокОбъект.Дата;
	////НаборДвиженийЗатраты.мТаблицаДвижений = ТаблицаДвиженийЗатраты;
	////НаборДвиженийЗатраты.ВыполнитьДвижения();
	////НаборДвиженийЗатраты.Записать(Ложь);

КонецПроцедуры

// Функция выполняет пропорциональное распределение суммы в соответствии
// с заданными коэффициентами распределения
//
// Параметры:
//  ИсхСумма   - распределяемая сумма
//  МассивКоэф - массив коэффициентов распределения
//  Точность   - точность округления при распределении. Необязателен.
//
//Возвращает:
//  МассивСумм - массив размерностью равный массиву коэффициентов, содержит
//               суммы в соответствии с весом коэффициента (из массива коэффициентов)
//               В случае если распределить не удалось (сумма = 0, кол-во коэф. = 0,
//               или суммарный вес коэф. = 0), тогда возвращается значение Неопределено
//
Функция РаспределитьПропорционально(Знач ИсхСумма, МассивКоэф, Знач Точность = 2, ПроверкаНулевыхЗначений=Истина) Экспорт

	Если МассивКоэф.Количество() = 0 Или (ПроверкаНулевыхЗначений И ИсхСумма = 0) Или ИсхСумма = Null Тогда
		Возврат Неопределено;
	КонецЕсли;

	СуммаКоэф  = 0;

	Для К = 0 По МассивКоэф.Количество() - 1 Цикл
		СуммаКоэф = СуммаКоэф + МассивКоэф[К];
	КонецЦикла;

	Если СуммаКоэф = 0 Тогда
		Возврат Неопределено;
	КонецЕсли;

	МассивСумм = Новый Массив(МассивКоэф.Количество());

	Для К = 0 По МассивКоэф.Количество() - 1 Цикл
		МассивСумм[К] = ?(СуммаКоэф <> 0, Окр(ИсхСумма * МассивКоэф[К] / СуммаКоэф, Точность, 1), 0);
		ИсхСумма = ИсхСумма - МассивСумм[К]; 
		СуммаКоэф = СуммаКоэф - МассивКоэф[К]; 
	КонецЦикла;

	Возврат МассивСумм;
КонецФункции

// Функция выполняет пропорциональное распределение суммы в соответствии
// с заданными коэффициентами распределения
//
// Параметры:
//		ИсхСумма - распределяемая сумма
//		МассивКоэф - массив коэффициентов распределения
//		Точность - точность округления при распределении. Необязателен.
//
//	Возврат:
//		МассивСумм - массив размерностью равный массиву коэффициентов, содержит
//			суммы в соответствии с весом коэффициента (из массива коэффициентов)
//          В случае если распределить не удалось (сумма = 0, кол-во коэф. = 0,
//          или суммарный вес коэф. = 0), тогда возвращается значение Неопределено
//
Функция РаспределитьПропорционально_2(Знач ИсхСумма, МассивКоэф, Знач Точность = 2) Экспорт

	Если МассивКоэф.Количество() = 0 Или ИсхСумма = 0 Или ИсхСумма = Null Тогда
		Возврат Неопределено;
	КонецЕсли;

	ИндексМакс = 0;
	МаксЗнач   = 0;
	РаспрСумма = 0;
	СуммаКоэф  = 0;

	Для К = 0 По МассивКоэф.Количество() - 1 Цикл

		МодульЧисла = ?(МассивКоэф[К] > 0, МассивКоэф[К], - МассивКоэф[К]);

		Если МаксЗнач < МодульЧисла Тогда
			МаксЗнач   = МодульЧисла;
			ИндексМакс = К;
		КонецЕсли;

		СуммаКоэф = СуммаКоэф + МассивКоэф[К];

	КонецЦикла;

	Если СуммаКоэф = 0 Тогда
		Возврат Неопределено;
	КонецЕсли;

	МассивСумм = Новый Массив(МассивКоэф.Количество());

	Для К = 0 По МассивКоэф.Количество() - 1 Цикл
		МассивСумм[К] = Окр(ИсхСумма * МассивКоэф[К] / СуммаКоэф, Точность, 1);
		РаспрСумма    = РаспрСумма + МассивСумм[К];
	КонецЦикла;

	// Погрешности округления отнесем на коэффицент с максимальным весом
	Если Не РаспрСумма = ИсхСумма Тогда
		МассивСумм[ИндексМакс] = МассивСумм[ИндексМакс] + ИсхСумма - РаспрСумма;
	КонецЕсли;

	Возврат МассивСумм;
КонецФункции
	
// Выполняет общие для всех документов действия связанные с пометкой на удаление
// счета фактуры при удалении документа, являющегося основание данного счета фактуры.
//
// Параметры:
//  ДокументОбъект  - объект документа, 
//  ВидСчетаФактуры - строка, вид счета-фактуры, по умолчанию "СчетФактураВыданный"
//
Процедура СинхронизацияПометкиНаУдалениеУСчетаФактуры(ДокументОбъект, ВидСчетаФактуры = "СчетФактураВыданный") Экспорт
	Если НЕ ДокументОбъект.ПометкаУдаления=ДокументОбъект.Ссылка.ПометкаУдаления Тогда
		СчетФактура = УчетНДС.НайтиПодчиненныйДокумент(ДокументОбъект.Ссылка, ВидСчетаФактуры);
		Если ЗначениеЗаполнено(СчетФактура) Тогда
			СчетФактураОбъект=СчетФактура.ПолучитьОбъект();
			СчетФактураОбъект.УстановитьПометкуУдаления(ДокументОбъект.ПометкаУдаления);			
			Если ДокументОбъект.ПометкаУдаления Тогда
				Сообщить("Документ «"+СчетФактура+"» помечен на удаление.", СтатусСообщения.Информация);
			Иначе
				Сообщить("У документа «"+СчетФактура+"» снята пометка на удаление.", СтатусСообщения.Информация);
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;		
КонецПроцедуры

// Формирует список обособленных структурных подразделений организации
//
Функция ПолучитьСписокОбособленныхПодразделенийОрганизации(Организация) Экспорт

	Запрос=Новый Запрос("ВЫБРАТЬ РАЗРЕШЕННЫЕ
	|	Организации.Ссылка,
	|	Организации.Наименование
	|ИЗ
	|	Справочник.Организации КАК Организации
	|
	|ГДЕ
	|	Организации.ГоловнаяОрганизация = &Организация");
	
    Запрос.УстановитьПараметр("Организация", Организация);
	СписокОрганизаций = Новый СписокЗначений;

	Выборка = Запрос.Выполнить().Выбрать(); 
	Пока Выборка.Следующий() Цикл
		СписокОрганизаций.Добавить(Выборка.Ссылка, Выборка.Наименование);
	КонецЦикла;

	Возврат СписокОрганизаций;

КонецФункции 

// Возвращает список организаций, которые являются обособленными подразделениями
// того же юр.лица, к которому относится переданная организация
//
Функция ПолучитьСписокОбособленныхПодразделений(Организация) Экспорт
	Запрос=Новый Запрос;
	Запрос.УстановитьПараметр("Организация", Организация);
	Запрос.Текст="
	|ВЫБРАТЬ РАЗРЕШЕННЫЕ
	|	ВЫБОР
	|		КОГДА Организации.ГоловнаяОрганизация = ЗНАЧЕНИЕ(Справочник.Организации.ПустаяСсылка)
	|			ТОГДА Организации.Ссылка
	|		ИНАЧЕ Организации.ГоловнаяОрганизация
	|	КОНЕЦ КАК ГоловнаяОрганизация
	|ПОМЕСТИТЬ ТаблицаГоловнойОрганизации
	|ИЗ
	|	Справочник.Организации КАК Организации
	|ГДЕ
	|	Организации.Ссылка = &Организация
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ РАЗРЕШЕННЫЕ
	|	Таб.ГоловнаяОрганизация КАК Организация,
	|	ПРЕДСТАВЛЕНИЕ(Таб.ГоловнаяОрганизация) КАК ОрганизацияПредставление
	|ИЗ
	|	ТаблицаГоловнойОрганизации КАК Таб
	|
	|ОБЪЕДИНИТЬ ВСЕ
	|
	|ВЫБРАТЬ
	|	Организации.Ссылка,
	|	ПРЕДСТАВЛЕНИЕ(Организации.Ссылка)
	|ИЗ
	|	Справочник.Организации КАК Организации
	|ГДЕ
	|	Организации.ГоловнаяОрганизация В
	|			(ВЫБРАТЬ
	|				Таб.ГоловнаяОрганизация
	|			ИЗ
	|				ТаблицаГоловнойОрганизации КАК Таб)
	|АВТОУПОРЯДОЧИВАНИЕ
	|";	
	СписокОП=Новый СписокЗначений;
	Выборка=Запрос.Выполнить().Выбрать();
	Пока Выборка.Следующий() Цикл
		СписокОП.Добавить(Выборка.Организация, Выборка.ОрганизацияПредставление);
	КонецЦикла;	
	Возврат СписокОП;	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ ПАРАМЕТРОВ СЕАНСА, ПЕРЕМЕННЫХ МОДУЛЯ ПРИЛОЖЕНИЯ

// Функция возвращает значение экспортных переменных модуля приложений из параметра сеанса
// Необходмо для возможности создания объектов на сервере
Функция ПолучитьЗначениеПеременной(ИмяПараметра, Кэш = Неопределено, КэшИзменен = Ложь) Экспорт
	
	Если Кэш = Неопределено Тогда
		// Кэш не был проинициализирован
		Кэш = Новый Структура;
	Иначе
		// Ищем значение в структуре
		НайденноеЗначение = Неопределено;
		Если Кэш.Свойство(ИмяПараметра, НайденноеЗначение) Тогда
			Возврат НайденноеЗначение;
		КонецЕсли;
	КонецЕсли;
	
	// Значение в КЭШе не нашли, получим значение из БД
	Если ВРег(ИмяПараметра) = ВРег("ВалютаРегламентированногоУчета") Тогда
		НайденноеЗначение = Константы.ВалютаРегламентированногоУчета.Получить();

	ИначеЕсли ВРег(ИмяПараметра) = ВРег("ВалютаУправленческогоУчета") Тогда
		НайденноеЗначение = Константы.ВалютаУправленческогоУчета.Получить();

	ИначеЕсли ВРег(ИмяПараметра) = ВРег("ОсновнаяОрганизация") Тогда	
		НайденноеЗначение = УправлениеПользователямиСервер.ПолучитьЗначениеПоУмолчанию("ОсновнаяОрганизация");

	ИначеЕсли ВРег(ИмяПараметра) = ВРег("ЗначенияНастроекПользователей") Тогда
		НайденноеЗначение = Новый Соответствие;
		
	ИначеЕсли ВРег(ИмяПараметра) = ВРег("ЗначенияДополнительныхПравПользователя") Тогда
		НайденноеЗначение = Новый Соответствие;
		
	ИначеЕсли ВРег(ИмяПараметра) = ВРег("СтатусВозврата") Тогда //Lee
		НайденноеЗначение = Неопределено;

	ИначеЕсли ВРег(ИмяПараметра) = ВРег("УчетПоВсемОрганизациям") Тогда // для регл.отчетов
		НайденноеЗначение=Истина;
		
	ИначеЕсли ВРег(ИмяПараметра) = ВРег("глТекущийПользователь") Тогда // для регл.отчетов
		НайденноеЗначение=ПараметрыСеанса.ТекущийПользователь;

	ИначеЕсли ВРег(ИмяПараметра) = ВРег("ИспользоватьСерииНоменклатуры") Тогда
		НайденноеЗначение=Константы.ИспользоватьСерииНоменклатуры.Получить();
				
	Иначе
		СтрокаИсключения = "Невозможно обработать параметр " + """" + ИмяПараметра + """" + " для получения значения";
		ВызватьИсключение СтрокаИсключения;
	КонецЕсли;
	
	Кэш.Вставить(ИмяПараметра, НайденноеЗначение);
	КэшИзменен = Истина;
	
	Возврат НайденноеЗначение;
	
КонецФункции

Процедура УстановитьЗначениеПеременной(ИмяПараметра, Кэш, ЗначениеПараметра, ОбновлятьВоВсехКэшах = Ложь) Экспорт
	
	Если Кэш.Свойство(ИмяПараметра) Тогда
		Кэш.Вставить(ИмяПараметра, ЗначениеПараметра);
	КонецЕсли;
	
	#Если Клиент ИЛИ ВнешнееСоединение Тогда
		Если ОбновлятьВоВсехКэшах Тогда
			КэшНаСервере=ПараметрыСеанса.ОбщиеЗначения.Получить();
			КэшНаСервере.Вставить(ИмяПараметра, ЗначениеПараметра);
			ПараметрыСеанса.ОбщиеЗначения = Новый ХранилищеЗначения(КэшНаСервере);
		КонецЕсли;
	#КонецЕсли
	
КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ МЕХАНИЗМА РИБ

Процедура ДобавитьПрефиксУзла(Префикс) Экспорт
	
	//Если ПараметрыСеанса.ИспользованиеРИБ1 Тогда
	//	Префикс = ПараметрыСеанса.ПрефиксУзлаРИБ + Префикс;
	//КонецЕсли;
	
КонецПроцедуры

Функция ОпределитьТекущийРежимРаботыМонопольный() Экспорт
	МассивСоединений = ПолучитьСоединенияИнформационнойБазы();
	НомерТекущегоСоединения = НомерСоединенияИнформационнойБазы();

	Для каждого Соединение ИЗ МассивСоединений Цикл
		Если Соединение.ИмяПриложения <> "Designer" И Соединение.НомерСоединения <> НомерТекущегоСоединения Тогда
			Возврат Ложь;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Истина;	
КонецФункции

Процедура СообщитьИнформацияОПрефиксации() Экспорт
	Если ПустаяСтрока(ПараметрыСеанса.ПрефиксУзлаРИБ) Тогда
		Сообщить("Для задействования механизма установки префиксов объектов необходимо установить константу ""Префикс узла для распределенной информационной базы"" 
			| и перезапустить текущий сеанс работы 1С:Предприятия.");
		Сообщить("Текущее значение префикса: " + ПараметрыСеанса.ПрефиксУзлаРИБ);
	КонецЕсли;	
КонецПроцедуры

// функция ищет элемент в массиве. Если находит - возвращает его индекс, иначе -1
Функция ВернутьИндексВМассиве(МассивДанные, Элемент) Экспорт 

	Если МассивДанные = Неопределено Тогда Возврат -1; КонецЕсли;
	
	Для ИндексЭлемента = 0 По МассивДанные.ВГраница() Цикл
		Если (МассивДанные[ИндексЭлемента] = Элемент) Тогда
			Возврат ИндексЭлемента;
		КонецЕсли;	
	КонецЦикла;

	// не нашли элемент
	Возврат -1;

КонецФункции

// РАБОТА С ПЕРЕМЕННЫМИ

// Меняет местами значения двух доступных для записи переменных
//
// Параметры
//  Источник - первая переменная
//  Приемник – вторая переменная
//
Процедура ПоменятьПеременныеМестами(Источник, Приемник) Экспорт

	тмп = Источник;
	Источник = Приемник;
	Приемник = Тмп;

КонецПроцедуры

// Отбирает из переданной таблицы строки по заданным критериям.
//
// Параметры:
//  Источник - ТаблицаЗначений, РезультатЗапроса, ОбластьЯчеекТабличногоДокумента. Таблица-источник.
//  СтруктураКритериев - Структура. Названия отборов и значения, по которым нужно отобрать строки.
//  СтруктураСложныхКритериев - Структура. Если свойство передано, то значение содержит вид сравнения.
//
// Возвращаемое значение:
//  РезультатЗапроса - таблица с нужными строками.
//
Функция ОтобратьСтрокиПоКритериям(Источник, СтруктураКритериев, СтруктураСложныхКритериев = Неопределено) Экспорт

	Перем ВидСравненияСложный;

	Если СтруктураСложныхКритериев = Неопределено Тогда
		СтруктураСложныхКритериев = Новый Структура;
	КонецЕсли;

	ПостроительЗапроса = Новый ПостроительЗапроса;
	ПостроительЗапроса.ИсточникДанных = Новый ОписаниеИсточникаДанных(Источник);

	Для Каждого Критерий Из СтруктураКритериев Цикл
		НовыйОтбор = ПостроительЗапроса.Отбор.Добавить(Критерий.Ключ);

		СтруктураСложныхКритериев.Свойство(Критерий.Ключ, ВидСравненияСложный);

		Если ВидСравненияСложный = Неопределено Тогда
			НовыйОтбор.Установить(Критерий.Значение);
		Иначе
			НовыйОтбор.Использование = Истина;
			НовыйОтбор.ВидСравнения = ВидСравненияСложный;
			НовыйОтбор.Значение = Критерий.Значение;
		КонецЕсли;
	КонецЦикла;

	Возврат ПостроительЗапроса.Результат;

КонецФункции

// Возвращает дату начала периода по имеющимся данным о:
// дате окончании периода, значении перечисления Период, количестве периодов.
// Кроме того, в случае, если задать отрицательную периодичность,- функция возвратит
// дату окончания периода по заданной дате начала периода
Функция ПолучитьДатуНачалаПериодаПоДатеОкончанияКоличествуПериодов(ДатаОкончания, ПериодСсылка, КоличествоПериодов) Экспорт
	
	Если КоличествоПериодов = 0 Тогда
		КоличествоПериодов = 1;
	КонецЕсли;
	
	Если ДатаОкончания = Неопределено Тогда
		
		Если КоличествоПериодов > 0 Тогда
			ДатаОкончания = КонецДня(ТекущаяДата());
		ИначеЕсли КоличествоПериодов < 0 Тогда
			ДатаОкончания = НачалоДня(ТекущаяДата());
		КонецЕсли;
		
	КонецЕсли;
	
	Если (ПериодСсылка = Перечисления.Периодичность.День) Тогда
		ДатаНачала = НачалоДня(ДатаОкончания - 60*60*24 * КоличествоПериодов);
	ИначеЕсли (ПериодСсылка = Перечисления.Периодичность.Неделя) Тогда
		ДатаНачала = НачалоДня(ДатаОкончания - 60*60*24*7 * КоличествоПериодов);
	ИначеЕсли (ПериодСсылка = Перечисления.Периодичность.Декада) Тогда
		ДатаНачала = НачалоДня(ДатаОкончания - 60*60*24*10 * КоличествоПериодов);
	ИначеЕсли (ПериодСсылка = Перечисления.Периодичность.Месяц) Тогда
		ДатаНачала = НачалоДня(ДобавитьМесяц(ДатаОкончания, -(КоличествоПериодов)));
	ИначеЕсли (ПериодСсылка = Перечисления.Периодичность.Квартал) Тогда
		ДатаНачала = НачалоДня(ДобавитьМесяц(ДатаОкончания, -(3 * КоличествоПериодов)));
	ИначеЕсли (ПериодСсылка = Перечисления.Периодичность.Полугодие) Тогда
		ДатаНачала = НачалоДня(ДобавитьМесяц(ДатаОкончания, -(6 * КоличествоПериодов)));
	ИначеЕсли (ПериодСсылка = Перечисления.Периодичность.Год) Тогда
		ДатаНачала = НачалоДня(ДобавитьМесяц(ДатаОкончания, -(12 * КоличествоПериодов)));
	КонецЕсли;
	
	Если КоличествоПериодов > 0 Тогда
		Возврат ДатаНачала + 60*60*24;
	ИначеЕсли КоличествоПериодов < 0 Тогда
		Возврат КонецДня(ДатаНачала - 60*60*24);
	КонецЕсли;
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С МЕХАНИЗМОМ НАСТРОЙКИ ПОРЯДКА ЭЛЕМЕНТОВ СПРАВОЧНИКА

Функция ПолучитьДополнениеЗапроса(Элемент, Запрос, БезПервогоИ = Ложь)

	ТекстЗапроса = "";
	
	Если Элемент.Метаданные().Иерархический = Истина Тогда
		Запрос.УстановитьПараметр("ТекущийРодитель", Элемент.Родитель);
		Если НЕ БезПервогоИ Тогда
			ТекстЗапроса = ТекстЗапроса + "
			|	И
			|";
		КонецЕсли; 
		ТекстЗапроса = ТекстЗапроса + "
		|	СправочникПорядка.Родитель = &ТекущийРодитель
		|";
	КонецЕсли; 
	
	Если Элемент.Метаданные().Владельцы.Количество() > 0 Тогда
		Запрос.УстановитьПараметр("ТекущийВладелец", Элемент.Владелец);
		Если НЕ (ПустаяСтрока(ТекстЗапроса) И БезПервогоИ) Тогда
			ТекстЗапроса = ТекстЗапроса + "
			|	И
			|";
		КонецЕсли; 
		ТекстЗапроса = ТекстЗапроса + "
		|	СправочникПорядка.Владелец = &ТекущийВладелец
		|";
	КонецЕсли; 

	Возврат ТекстЗапроса;
	
КонецФункции //УДАЛИТЬ!

Функция НазначитьНовыйПорядок(ЭлементОбъект)

	ИмяТаблицы = ЭлементОбъект.Метаданные().Имя;
	
	Запрос=Новый Запрос;
	Запрос.Текст="
	|ВЫБРАТЬ РАЗРЕШЕННЫЕ ПЕРВЫЕ 1
	|	СправочникПорядка.Порядок
	|ИЗ
	|	Справочник." + ИмяТаблицы + " КАК СправочникПорядка";
	
	ДополнениеЗапроса = ПолучитьДополнениеЗапроса(ЭлементОбъект, Запрос, Истина);
	
	Если НЕ ПустаяСтрока(ДополнениеЗапроса) Тогда
		Запрос.Текст = Запрос.Текст + "
		|ГДЕ
		|" + ДополнениеЗапроса + "
		|";
	КонецЕсли; 
	
	Запрос.Текст = Запрос.Текст + "
	|УПОРЯДОЧИТЬ ПО
	|	СправочникПорядка.Порядок УБЫВ
	|";
	
	РезультатЗапроса = Запрос.Выполнить();
	Если РезультатЗапроса.Пустой() Тогда
		Возврат 0;
	КонецЕсли;

	Выборка=РезультатЗапроса.Выбрать();
	Выборка.Следующий();
	Возврат (Выборка.Порядок + 1)
КонецФункции //УДАЛИТЬ!

Процедура ПередЗаписьюОбъектаПорядка(Отказ, ЭтотОбъект, КонтролироватьПорядок) Экспорт

	Если ЭтотОбъект.ЭтоНовый() Тогда
		ЭтотОбъект.Порядок = НазначитьНовыйПорядок(ЭтотОбъект);
	Иначе
		Если ЭтотОбъект.Ссылка.Родитель <> ЭтотОбъект.Родитель ИЛИ ЭтотОбъект.Ссылка.Владелец <> ЭтотОбъект.Владелец Тогда
			ЭтотОбъект.Порядок = НазначитьНовыйПорядок(ЭтотОбъект);
		КонецЕсли;
	КонецЕсли;
	
	Если КонтролироватьПорядок Тогда
		ИмяТаблицы = ЭтотОбъект.Метаданные().Имя;

		Запрос = Новый Запрос;		
		Запрос.УстановитьПараметр("ТекущийПорядок", ЭтотОбъект.Порядок);
		Запрос.Текст="
		|ВЫБРАТЬ ПЕРВЫЕ 1
		|	СправочникПорядка.Порядок
		|ИЗ
		|	Справочник." + ИмяТаблицы + " КАК СправочникПорядка
		|ГДЕ
		|	СправочникПорядка.Порядок = &ТекущийПорядок
		|";
		
		Если НЕ ЭтотОбъект.ЭтоНовый() Тогда
			Запрос.УстановитьПараметр("ТекущаяСсылка", ЭтотОбъект.Ссылка);
			Запрос.Текст = Запрос.Текст + "
			|И
			|	СправочникПорядка.Ссылка <> &ТекущаяСсылка
			|";
		КонецЕсли; 
		
		Запрос.Текст = Запрос.Текст + ПолучитьДополнениеЗапроса(ЭтотОбъект, Запрос);
		
		Если НЕ Запрос.Выполнить().Пустой() Тогда
			Отказ = Истина;
			Сообщить("Не уникальный порядок элемента справочника.");
		КонецЕсли;
	
	КонецЕсли; 

КонецПроцедуры //УДАЛИТЬ!

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С ФАЙЛАМИ

// функция возвращает часть строки после последнего встреченного символа в строке
Функция ПолучитьЧастьСтрокиОтделеннойСимволом(Знач ИсходнаяСтрока, Знач СимволПоиска)
	ПозицияСимвола = СтрДлина(ИсходнаяСтрока);
	Пока ПозицияСимвола >= 1 Цикл
		Если Сред(ИсходнаяСтрока, ПозицияСимвола, 1) = СимволПоиска Тогда
			Возврат Сред(ИсходнаяСтрока, ПозицияСимвола + 1); 
		КонецЕсли;
		ПозицияСимвола = ПозицияСимвола - 1;	
	КонецЦикла;

	Возврат "";  	
КонецФункции

// Выделяет из имени файла его расширение (набор символов после последней точки).
//
// Параметры
//  ИмяФайла     – Строка, содержащая имя файла, неважно с именем каталога или без.
//
// Возвращаемое значение:
//   Строка – расширение файла.
//
Функция ПолучитьРасширениеФайла(Знач ИмяФайла) Экспорт
	Возврат ПолучитьЧастьСтрокиОтделеннойСимволом(ИмяФайла, ".");
КонецФункции

// Выделяет из полного пути к файлу его имя (набор символов после последней \).
//
// Параметры
//  ПутьКФайлу     – Строка, содержащая имя файла, неважно с именем каталога или без.
//
// Возвращаемое значение:
//   Строка – расширение файла.
//
Функция ПолучитьИмяФайлаИзПолногоПути(Знач ПутьКФайлу) Экспорт
	Возврат ПолучитьЧастьСтрокиОтделеннойСимволом(ПутьКФайлу, "\");
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ ДЛЯ РАБОТЫ С XML

// Функция осуществляет построение дерева XML.
//
// Параметры
//  XML             - <ЧтениеXML>
//                  - Объект, при помощи которого осуществляется чтение
//                    файла отчета.
//
//  Дерево          - <Структура>
//                  - Дерево XML.
//
//  ПервыйВызов     - <Булево>
//                  - Служебный параметр.
//
// Возвращаемое значение:
//  <Булево>        - Результат выполнения.
//
Функция ПостроитьДеревоXML(XML, Дерево, ПервыйВызов = Истина) Экспорт

	Результат = Истина;
	Имя       = "";
	Врем      = Неопределено;
	Врем2     = Неопределено;
	Врем3     = Неопределено;

	Если ПервыйВызов Тогда
		Дерево = Новый Структура();
	КонецЕсли;

	Если XML.Прочитать() Тогда
		Если XML.ТипУзла = ТипУзлаXML.НачалоЭлемента Тогда
			Имя  = XML.ЛокальноеИмя;
			Врем = Новый Структура();
			Пока ПостроитьДеревоXML(XML, Врем, Ложь) Цикл
			КонецЦикла;
			Пока XML.Имя <> Имя Цикл
				Если XML.ТипУзла = ТипУзлаXML.Текст Тогда
					Врем = XML.Значение;
				КонецЕсли;
				Если Не XML.Прочитать() Тогда
					Результат = Ложь;
					Возврат Результат;
				КонецЕсли;
			КонецЦикла;
			Дерево.Свойство(Имя, Врем2);
			Если Врем2 = Неопределено Тогда
				Врем2 = Врем;
			Иначе
				Если ТипЗнч(Врем2) = Тип("Массив") Тогда
					Врем2.Добавить(Врем);
				Иначе
					Врем3 = Новый Массив();
					Врем3.Добавить(Врем2);
					Врем3.Добавить(Врем);
					Врем2 = Врем3;
				КонецЕсли;
			КонецЕсли;
			Дерево.Вставить(Имя, Врем2);
		Иначе
			Результат = Ложь;
		КонецЕсли;
	Иначе
		Результат = Ложь;
	КонецЕсли;

	Возврат Результат;

КонецФункции

// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С УЧЕТНОЙ ПОЛИТИКОЙ

Функция ПолучитьПараметрыУчетнойПолитики(МоментВремени, Отказ, Организация=Неопределено, Учет="Упр", СообщатьОбОшибке=Истина) Экспорт
	СтруктураУчетнойПолитики=Новый Структура;
	Для каждого мдРесурсы Из Метаданные.РегистрыСведений.УчетнаяПолитика.Ресурсы Цикл
		Значение="";
		Если мдРесурсы.Тип=Новый ОписаниеТипов("Булево") Тогда
			Значение=Ложь;
		ИначеЕсли мдРесурсы.Тип=Новый ОписаниеТипов("Дата", Новый КвалификаторыДаты(ЧастиДаты.Дата)) Тогда
			Значение=Дата('00010101');
		КонецЕсли;
		СтруктураУчетнойПолитики.Вставить(мдРесурсы.Имя, Значение);
	КонецЦикла;

	СтруктураУчетнойПолитики.Вставить("СпособОценкиМПЗ", Перечисления.СпособыОценки.ФИФО);
	СтруктураУчетнойПолитики.Вставить("СложныйУчетНДСНал", Ложь);
	СтруктураУчетнойПолитики.Вставить("МоментОпределенияНалоговойБазыНДСБух", Перечисления.МоментыОпределенияНалоговойБазыНДС.ПоОтгрузке);

	Если ТипЗнч(МоментВремени)=Тип("Дата") Тогда
		НаДату=МоментВремени;
	Иначе
		НаДату=?(ЗначениеЗаполнено(МоментВремени), МоментВремени.Дата, ТекущаяДата());
	КонецЕсли;

	Если НЕ ЗначениеЗаполнено(НаДату) Тогда
		Если СообщатьОбОшибке Тогда
			СообщитьОбОшибке("Не указана дата на которую необходимо получить параметры учетной политики", Отказ);
		КонецЕсли;
		Отказ=Истина; Возврат СтруктураУчетнойПолитики;	
	КонецЕсли;

	Запрос=Новый Запрос;
	Запрос.УстановитьПараметр("НаДату", НаДату);
	Запрос.УстановитьПараметр("Организация", ?(Организация=Неопределено, Справочники.Организации.ПустаяСсылка(), Организация));
	Запрос.Текст="
	|ВЫБРАТЬ
	|	*
	|ИЗ
	|	РегистрСведений.УчетнаяПолитика.СрезПоследних(&НаДату, Организация=&Организация) КАК УчетнаяПолитика
	|";
	тзУчетнаяПолитика=Запрос.Выполнить().Выгрузить();

	Если тзУчетнаяПолитика.Количество()=0 Тогда
		Отказ = Истина;
		Если СообщатьОбОшибке Тогда
			СообщитьОбОшибке("Не указаны параметры учетной политики ("+СокрЛП(Организация)+") на "+Формат(НаДату, "ДЛФ=DD"), Отказ);
		КонецЕсли;
		Возврат СтруктураУчетнойПолитики;
	КонецЕсли;

	СтрокаУчетнойПолитики=тзУчетнаяПолитика[0];

	Для Каждого Колонка Из тзУчетнаяПолитика.Колонки Цикл
		СтруктураУчетнойПолитики.Вставить(Колонка.Имя, СтрокаУчетнойПолитики[Колонка.Имя]);
	КонецЦикла;

	//Переопределим значения для упр. учета
	Если Организация=Неопределено Тогда
		СтруктураУчетнойПолитики.Вставить("ОрганизацияПрименяетУСН", (Константы.ПрименяемыеСистемыНалогообложения.Получить() = Перечисления.ПрименяемыеСистемыНалогообложения.УпрощеннаяСистемаНалогообложения));
	Иначе
		СтруктураУчетнойПолитики.Вставить("ОрганизацияПрименяетУСН", СтрокаУчетнойПолитики.СистемаНалогообложения = Перечисления.СистемыНалогообложения.Упрощенная);
	КонецЕсли;
	СтруктураУчетнойПолитики.МоментОпределенияНалоговойБазыНДСБух=СтруктураУчетнойПолитики.МоментОпределенияНалоговойБазыНДС;
	СтруктураУчетнойПолитики.СложныйУчетНДСНал=СтруктураУчетнойПолитики.СложныйУчетНДС;

	СтруктураУчетнойПолитики.Вставить("УСН", СтрокаУчетнойПолитики.СистемаНалогообложения = Перечисления.СистемыНалогообложения.Упрощенная);
	Если СтруктураУчетнойПолитики.Свойство("МоментОпределенияНалоговойБазыНДС") и СтруктураУчетнойПолитики.МоментОпределенияНалоговойБазыНДС = Перечисления.МоментыОпределенияНалоговойБазыНДС.ПоОплате Тогда
		СтруктураУчетнойПолитики.Вставить("МоментОпределенияНалоговойБазыНДС", Перечисления.МоментыОпределенияНалоговойБазыНДС.ПоОтгрузке);
	КонецЕсли;	

	Возврат СтруктураУчетнойПолитики;	
КонецФункции

// Функция проверяет наличие в строке только цифр
//
// Параметры
//  СтрокаПроверки - Строка для проверки только цифр
//
// Возвращаемое значение:
//   Булево
//
Функция ТолькоЦифрыВСтроке(Знач СтрокаПроверки, УчитыватьЛидирующиеНули = Истина, УчитыватьПробелы = Истина) Экспорт
	
	Если ТипЗнч(СтрокаПроверки) <> Тип("Строка") Тогда Возврат Ложь; КонецЕсли;
	
	Если НЕ ЗначениеЗаполнено(СтрокаПроверки) Тогда Возврат Истина; КонецЕсли; 
	
	Если НЕ УчитыватьПробелы Тогда
		СтрокаПроверки = СтрЗаменить(СтрокаПроверки, " ", "");
	КонецЕсли;
	
	Если НЕ УчитыватьЛидирующиеНули Тогда
		НомерПервойЦифры = 0;
		Для а = 1 По СтрДлина(СтрокаПроверки) Цикл
			НомерПервойЦифры = НомерПервойЦифры + 1;
			КодСимвола = КодСимвола(Сред(СтрокаПроверки, а, 1));
			Если КодСимвола <> 48 Тогда
				Прервать;
			КонецЕсли;
		КонецЦикла;
		СтрокаПроверки = Сред(СтрокаПроверки, НомерПервойЦифры);
	КонецЕсли;
	
	Для а = 1 По СтрДлина(СтрокаПроверки) Цикл
		КодСимвола = КодСимвола(Сред(СтрокаПроверки, а, 1));
		Если НЕ (КодСимвола >= 48 И КодСимвола <= 57) Тогда
			Возврат Ложь;
		КонецЕсли; 
	КонецЦикла; 

	Возврат Истина;
	
КонецФункции


// Функция формирует структуру таблицы значений для отражения производственных затрат в регистрах.
//
Функция СформироватьТаблицуЗатрат() Экспорт

	ТаблицаЗатрат=Новый ТаблицаЗначений;
	ТаблицаЗатрат.Колонки.Добавить("Номенклатура",				Новый ОписаниеТипов("СправочникСсылка.Номенклатура"));
	ТаблицаЗатрат.Колонки.Добавить("ХарактеристикаНоменклатуры",Новый ОписаниеТипов("СправочникСсылка.ХарактеристикиНоменклатуры"));
	ТаблицаЗатрат.Колонки.Добавить("СерияНоменклатуры",			Новый ОписаниеТипов("СправочникСсылка.СерииНоменклатуры"));

	ТаблицаЗатрат.Колонки.Добавить("СтатьяЗатрат",				Новый ОписаниеТипов("СправочникСсылка.СтатьиЗатрат"));
	ТаблицаЗатрат.Колонки.Добавить("НоменклатурнаяГруппа",		Новый ОписаниеТипов("СправочникСсылка.НоменклатурныеГруппы"));
	ТаблицаЗатрат.Колонки.Добавить("Подразделение",				Новый ОписаниеТипов("СправочникСсылка.Подразделения"));
	ТаблицаЗатрат.Колонки.Добавить("СпособРаспределенияЗатратНаВыпуск");
	ТаблицаЗатрат.Колонки.Добавить("Заказ");
	ТаблицаЗатрат.Колонки.Добавить("Проект");

	ТаблицаЗатрат.Колонки.Добавить("Продукция",					Новый ОписаниеТипов("СправочникСсылка.Номенклатура"));
	ТаблицаЗатрат.Колонки.Добавить("ХарактеристикаПродукции", 	Новый ОписаниеТипов("СправочникСсылка.ХарактеристикиНоменклатуры"));
	ТаблицаЗатрат.Колонки.Добавить("СерияПродукции",			Новый ОписаниеТипов("СправочникСсылка.СерииНоменклатуры"));

	ТаблицаЗатрат.Колонки.Добавить("Количество",				ПолучитьОписаниеТиповЧисла( 15, 3));
	ТаблицаЗатрат.Колонки.Добавить("Сумма",						ПолучитьОписаниеТиповЧисла( 15, 2));
	ТаблицаЗатрат.Колонки.Добавить("СуммаРегл",					ПолучитьОписаниеТиповЧисла( 15, 2));
	ТаблицаЗатрат.Колонки.Добавить("СуммаНал",					ПолучитьОписаниеТиповЧисла( 15, 2));
	ТаблицаЗатрат.Колонки.Добавить("ПостояннаяРазница",			ПолучитьОписаниеТиповЧисла( 15, 2));
	ТаблицаЗатрат.Колонки.Добавить("ВременнаяРазница",			ПолучитьОписаниеТиповЧисла( 15, 2));

	Возврат ТаблицаЗатрат;
КонецФункции

//Предназначена для получения массива пустых значений, содержащих значение Неопределено и значения переданного типа или описания типов
Функция МассивПустыхЗначений(ОписаниеТипов) Экспорт
	МассивЗначений=Новый Массив;
	МассивЗначений.Добавить(неопределено);
	Если ТипЗнч(ОписаниеТипов)=Тип("ОписаниеТипов") Тогда
		Для каждого Тип из ОписаниеТипов.Типы() Цикл
			МассивЗначений.Добавить(ПустоеЗначениеТипа(Тип));
		КонецЦикла;
	ИначеЕсли ТипЗнч(ОписаниеТипов)=Тип("Тип") Тогда	
		МассивЗначений.Добавить(ПустоеЗначениеТипа(ОписаниеТипов));
	КонецЕсли;
	
	Возврат МассивЗначений;
КонецФункции

// Если в шапке переданного документа есть реквизит с указанным именем, то возвращается его значение.
// Если такого реквизита нет - возвращается Неопределено.
//
// Параметры:
//  ИмяРеквизита - Строка. Имя искомого реквизита.
//  ДокументОбъект - объект переданного документа.
//  МетаданныеДокумента - Метаданные переданного документа.
//  ПустоеЗначение - значение, которое должно вернуться, если в шапке нет такого реквизита,
//  если не передано, то возвращается значение Неопределено.
//
// Возвращаемое значение:
//  Значение реквизита - значение найденного реквизита или ПустоеЗначение.
//
Функция ПолучитьРеквизитШапки(ИмяРеквизита, ДокументОбъект, МетаданныеДокумента, ПустоеЗначение=Неопределено) Экспорт
	Возврат ?(УправлениеМетаданными.ЕстьРеквизит(ИмяРеквизита, МетаданныеДокумента), ДокументОбъект[ИмяРеквизита], ПустоеЗначение);
КонецФункции

// Процедура заполняет структуру таблиц документа, значением которое будет одинаковым для всех таблиц (например значением шапки документа)
//
// Параметры:
//  СтруктТаблицДокумента   - структура таблиц документа, сформированная функцией ЗагрузитьТаблицыДокументаВСтруктуру()
//  ИмяПоля                 - имя колонки в таблицах локумента, в которую будет установлено новое значение
//  УстанавливаемоеЗначение - значение, которое надо установить в таблицы документа
//  СтрТабЧасти             - имена таб. частей документа в которые необходимо установить новое значение. строка, в которой
//                            имена таб. частей разделены запятыми. необязательный параметр, по умолчанию - все таблицы.
//
Процедура УстановитьЗначениеВТаблицыДокумента(СтруктТаблицДокумента, ИмяПоля, УстанавливаемоеЗначение, СтрТабЧасти = "") Экспорт
	СтруктТабЧасти = ?( ПустаяСтрока(СтрТабЧасти), СтруктТаблицДокумента, Новый Структура(СтрТабЧасти));
	Для Каждого ТабЧасть Из СтруктТабЧасти Цикл	
		Если СтруктТаблицДокумента[ТабЧасть.Ключ].Количество() > 0 Тогда
		    СтруктТаблицДокумента[ТабЧасть.Ключ].ЗаполнитьЗначения( УстанавливаемоеЗначение, ИмяПоля);
		КонецЕсли;	
	КонецЦикла;	
КонецПроцедуры

// Процедура формирует движение в регистр на основании данных в таблицах документов
//
//Параметры:
//  Движение              - движение документа, в которое необходимо произвести добавление записей (т.е. регистр)
//  ВидДвижения           - вид движения накопления (приход/расход)
//  СтруктТаблицДокумента - структура таблиц документа, сформированная функцией ЗагрузитьТаблицыДокументаВСтруктуру()
//  ДатаДвижения          - дата на которую будут формироваться записи
//
Процедура ЗаписатьТаблицыДокументаВРегистр(Движение, ВидДвижения, СтруктТаблицДокумента, ДатаДвижения) Экспорт
	Движение.мПериод = ДатаДвижения;
	Для Каждого ТабЧасть Из СтруктТаблицДокумента Цикл
		// Пропускаем пустые табличные части
		Если ТабЧасть.Значение.Количество() = 0 Тогда Продолжить; КонецЕсли;

		Движение.мТаблицаДвижений = ТабЧасть.Значение;
		Если ВидДвижения = Неопределено Тогда // Регистр сведений
			ВыполнитьДвижениеПоРегистру(Движение);
		Иначе // Регистр накопления
			ВыполнитьДвижениеПоРегистру(Движение, ВидДвижения);
		КонецЕсли;
	КонецЦикла;
КонецПроцедуры

// Функция загружает таблицы документа в таблицы соответствующие структуре регистров
//
// Параметры:
//  Движение - движение документа (т.е. регистр)
//  СтруктТаблицДокумента - структура содержашая таблицы документа. ключ - имя таблицы, значение - таблица значений с данными документа.
//
// Возвращаемое значение:
//  Структура, в которой ключ - это имя таблицы документа, соответствующий параметру СтруктТаблицДокумента,
//  значение - таблица значений, со структурой соответствующей структуре параметра (т.е. регистра) Движение
//  В таблицы значений данные загружаются по соответствию с имен полей.
//
Функция ЗагрузитьТаблицыДокументаВСтруктуру(Движение, СтруктТаблицДокумента) Экспорт
	ПустаяТабРегистра=Движение.Выгрузить();
	ПустаяТабРегистра.Очистить();
	
	СтруктДанных = Новый Структура;
	Для Каждого ТабЧасть Из СтруктТаблицДокумента Цикл

		ТабРегистра = ПустаяТабРегистра.Скопировать();

		Если ТабЧасть.Значение <> Неопределено И ТабЧасть.Значение.Количество() > 0 Тогда
			ЗагрузитьВТаблицуЗначений(ТабЧасть.Значение, ТабРегистра);
		КонецЕсли;
		
		СтруктДанных.Вставить(ТабЧасть.Ключ, ТабРегистра);
	КонецЦикла;
	
	Возврат СтруктДанных;
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С КРИТЕРИЯМИ ОТБОРА

Функция ПолучитьТипИзмеренияПоУмолчанию(ТипЗначения) Экспорт
	Для каждого Тип Из ТипЗначения.Типы() Цикл
		ОбъектМетаданных=Метаданные.НайтиПоТипу(Тип);
		Если ОбъектМетаданных=Неопределено Тогда Продолжить; КонецЕсли;		
		Если НЕ Метаданные.Справочники.Найти(ОбъектМетаданных.Имя)=Неопределено И ОбъектМетаданных.Иерархический Тогда
			Возврат ТипИзмеренияПостроителяОтчета.Иерархия;
		КонецЕсли;
	КонецЦикла;

	Возврат ТипИзмеренияПостроителяОтчета.Элементы;	
КонецФункции

Процедура ДобавитьПрефиксОрганизации(ДокументОбъект, Префикс) Экспорт
	// Если  нет реквизита "Организация" или для нее не задан префикс, то 
	// используем пустой префикс, иначе используем префикс организации.
	МетаданныеДокумента = ДокументОбъект.Метаданные();

	Если Не УправлениеМетаданными.ЕстьРеквизит("Организация", МетаданныеДокумента)  Или НЕ ЗначениеЗаполнено(ДокументОбъект.Организация.Префикс) Тогда
		Префикс = "0";
	Иначе
		Префикс = ДокументОбъект.Организация.Префикс;
	КонецЕсли;
Конецпроцедуры

Процедура ПриУстановкеКодаПВХПриУстановкеНовогоКода(Источник, СтандартнаяОбработка, Префикс) Экспорт
	
	//*** ОбщегоНазначения.ДобавитьПрефиксУзла(Префикс);
	
КонецПроцедуры

// Функция определяет наличие клиентских подключений к базе других пользователей
Функция ЕстьДругиеПользователиВБазе() Экспорт
	МассивСоединений = ПолучитьСоединенияИнформационнойБазы();
	НомерТекущегоСоединения = НомерСоединенияИнформационнойБазы();
	
	Для каждого Соединение ИЗ МассивСоединений Цикл
		Если Соединение.ИмяПриложения <> "Designer" И Соединение.НомерСоединения <> НомерТекущегоСоединения Тогда
			Возврат Истина;
		КонецЕсли;
	КонецЦикла;

	Возврат Ложь;
КонецФункции

// Функция "расщепляет" строку на подстроки, используя заданный 
//		разделитель. Разделитель может иметь любую длину. 
//		Если в качестве разделителя задан пробел, рядом стоящие пробелы 
//		считаются одним разделителем, а ведущие и хвостовые пробелы параметра Стр
//		игнорируются.
//		Например, 
//		РазложитьСтрокуВМассивПодстрок(",ку,,,му", ",") возвратит массив значений из пяти элементов, 
//		три из которых - пустые строки, а 
//		РазложитьСтрокуВМассивПодстрок(" ку   му", " ") возвратит массив значений из двух элементов
//
//	Параметры: 
//		Стр - 			строка, которую необходимо разложить на подстроки. 
//						Параметр передается по значению.
//		Разделитель - 	строка-разделитель, по умолчанию - запятая.
//
//
//	Возвращаемое значение:
//		массив значений, элементы которого - подстроки
//
Функция РазложитьСтрокуВМассивПодстрок(Знач Стр, Разделитель = ",") Экспорт
	Возврат ЗначениеИзСтрокиВнутр("{""#"",51e7a0d2-530b-11d4-b98a-008048da3034,{0,{""S"","""+СтрЗаменить(Стр, Разделитель, """},{""S"",""")+"""}}}");
КонецФункции

// Функция определяет дату и время начала календарной декады для указанной даты.
//
// Параметры:
//  ТекущаяДата - Исходная дата.
//
// Возвращаемое значение:
//  Дата.
//
Функция ПолучитьНачалоДекады(ИсходнаяДата) Экспорт
	ДеньМесяца = День(ИсходнаяДата);

	Если ДеньМесяца < 10 Тогда
		Результат = НачалоМесяца(ИсходнаяДата);
	ИначеЕсли ДеньМесяца < 20 Тогда
		Результат = НачалоМесяца(ИсходнаяДата) + 60 * 60 * 24 * 10;
	Иначе
		Результат = НачалоМесяца(ИсходнаяДата) + 60 * 60 * 24 * 20;
	КонецЕсли;

	Возврат Результат;
КонецФункции

// Функция определяет дату и время конца календарной декады для указанной даты.
//
// Параметры:
//  ТекущаяДата - Исходная дата.
//
// Возвращаемое значение:
//  Дата.
//
Функция ПолучитьКонецДекады(ИсходнаяДата) Экспорт
	ДеньМесяца = День(ИсходнаяДата);

	Если ДеньМесяца < 10 Тогда
		Результат = КонецДня(НачалоМесяца(ИсходнаяДата) + 60 * 60 * 24 * 9);
	ИначеЕсли ДеньМесяца < 20 Тогда
		Результат = КонецДня(НачалоМесяца(ИсходнаяДата) + 60 * 60 * 24 * 19);
	Иначе
		Результат = КонецМесяца(ИсходнаяДата);
	КонецЕсли;

	Возврат Результат;
КонецФункции

// Функция определяет дату и время начала полугодия для указанной даты.
//
// Параметры:
//  ТекущаяДата - Исходная дата.
//
// Возвращаемое значение:
//  Дата.
//
Функция ПолучитьНачалоПолугодия(ИсходнаяДата) Экспорт
	Если Месяц(ИсходнаяДата) < 7 Тогда
		Результат = НачалоГода(ИсходнаяДата);
	Иначе
		Результат = ДобавитьМесяц(НачалоГода(ИсходнаяДата), 6);
	КонецЕсли;

	Возврат Результат;
КонецФункции

// Функция определяет дату и время конца полугодия для указанной даты.
//
// Параметры:
//  ТекущаяДата - Исходная дата.
//
// Возвращаемое значение:
//  Дата.
//
Функция ПолучитьКонецПолугодия(ИсходнаяДата) Экспорт
	Если Месяц(ИсходнаяДата) < 7 Тогда
		Результат = ДобавитьМесяц(КонецГода(ИсходнаяДата), -6);
	Иначе
		Результат = КонецГода(ИсходнаяДата);
	КонецЕсли;

	Возврат Результат;
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ УПРАВЛЕНИЯ ПЕРСОНАЛОМ

// Функция формирует фамилию и инициалы либо по наименованию элемента спр-ка ФизическиеЛица
//  либо по переданным строкам.
//  Если передан Объект, то извлеченная из него строка считается совокупностью 
//  Фамилия + Имя + Отчество, разделенными пробелами.
//
// Параметры
//  Объект		- строка или ссылка или объект элемента спр-ка ФизическиеЛица.
//  Фамилия		- фамилия физ. лица.
//  Имя			- имя физ. лица.
//  Отчество	- отчество физ. лица.
//
// Возвращаемое значение 
//  Фамилия и Инициалы одной строкой. Побочные эффекты - переданная целая строка 
//  Побочные эффекты - переданная целая строка разбивается на подстроки, соответствующие
//  отдельным Фамилии,Имени и Отчеству
//
Функция ФамилияИнициалыФизЛица(Объект = "", Фамилия = " ", Имя = " ", Отчество = " ") Экспорт

	ТипОбъекта = ТипЗнч(Объект);
	Если ТипОбъекта = Тип("Строка") Тогда
		ФИО = ОбщегоНазначения.РазложитьСтрокуВМассивПодстрок(СокрЛП(Объект)," ");
	ИначеЕсли ТипОбъекта = Тип("СправочникСсылка.ФизическиеЛица") или ТипОбъекта = Тип("СправочникОбъект.ФизическиеЛица") Тогда 
		ФИО = ОбщегоНазначения.РазложитьСтрокуВМассивПодстрок(СокрЛП(Объект.Наименование)," ");
	Иначе
		// используем возможно переданные отдельные строки
		Возврат ?(НЕ ПустаяСтрока(Фамилия), Фамилия + ?(НЕ ПустаяСтрока(Имя)," " + Лев(Имя,1) + "." + ?(НЕ ПустаяСтрока(Отчество),Лев(Отчество,1)+".", ""), ""), "")
	КонецЕсли;
			
	КоличествоПодстрок = ФИО.Количество();
	Фамилия = ?(КоличествоПодстрок > 0,ФИО[0],"");
	Имя		= ?(КоличествоПодстрок > 1,ФИО[1],"");
	Отчество= ?(КоличествоПодстрок > 2,ФИО[2],"");
	
	Возврат ?(НЕ ПустаяСтрока(Фамилия), Фамилия + ?(НЕ ПустаяСтрока(Имя)," " + Лев(Имя,1) + "." + ?(НЕ ПустаяСтрока(Отчество),Лев(Отчество,1)+".", ""), ""), "");

КонецФункции

Функция ПрименениеУСН(Организация, Знач Дата, УчетнаяПолитика=Неопределено) Экспорт
	
	ЗначениеПоУмолчанию=(Константы.ПрименяемыеСистемыНалогообложения.Получить() = Перечисления.ПрименяемыеСистемыНалогообложения.УпрощеннаяСистемаНалогообложения);

	Если НЕ ЗначениеЗаполнено(Организация) Тогда Возврат ЗначениеПоУмолчанию; КонецЕсли;
	Если НЕ ЗначениеЗаполнено(Дата) Тогда Дата = ТекущаяДата(); КонецЕсли;
	
	Если УчетнаяПолитика=Неопределено Тогда
		УчетнаяПолитика=ПолучитьПараметрыУчетнойПолитики(Дата, Ложь, Организация,,Ложь);
	КонецЕсли;

	Если УчетнаяПолитика.Количество()=0 Тогда Возврат ЗначениеПоУмолчанию; КонецЕсли;

	Если УчетнаяПолитика.Свойство("СистемаНалогообложения")=Ложь Тогда Возврат Ложь; КонецЕсли; 
	
	Возврат УчетнаяПолитика.СистемаНалогообложения = Перечисления.СистемыНалогообложения.Упрощенная;

КонецФункции

//Определяет применяется ли упрощенная система налогообложения
//
Функция ПрименениеУСНДоходы(Организация, Знач Дата, Отказ = Ложь) Экспорт

	Если НЕ ЗначениеЗаполнено(Организация) Тогда Возврат Ложь; КонецЕсли;
	Если НЕ ЗначениеЗаполнено(Дата) Тогда Дата = ТекущаяДата(); КонецЕсли;

	ПараметрыУчетнойПолитики = ПолучитьПараметрыУчетнойПолитики(Дата, Отказ, Организация,,Ложь);
	Если Отказ = Истина Тогда Возврат Ложь; КонецЕсли;

	Если НЕ ПараметрыУчетнойПолитики.УСН Тогда Возврат Ложь; КонецЕсли;
	
	Если ПараметрыУчетнойПолитики.ОбъектНалогообложенияУСН = Перечисления.ОбъектыНалогообложенияПоУСН.Доходы Тогда
		Возврат Истина;
	КонецЕсли;

	Возврат Ложь;
КонецФункции

// Выполняет в табличном поле приведение значений субконто к типу, соответствующему счету
// сведения о счете передаются через параметр СведенияОСчете
// используется для табличных полей, содержащих колонки типа Счет и соответствующие ему субконто
//
// Параметры:
//	ТабличноеПоле 	- табличное поле 
//  ДтКт 			- строка "Дт", "Кт" или "" - часть имени колонки табличного поля
// 					для колонок табличного поля поддерживаются имена 
//					типа СубконтоДт1, СубконтоКт1, Субконто1...
//  СведенияОСчете 	- структура
//					  КоличествоСубконто - число
//                    ТипСубконто1 - описание типа
//                    ТипСубконто2 - описание типа
//                    ТипСубконто3 - описание типа
//					  ВидСубконто1Представление - представление вида субконто - в данной процедуре не используется
//					  ВидСубконто2Представление - представление вида субконто - в данной процедуре не используется
//					  ВидСубконто3Представление - представление вида субконто - в данной процедуре не используется
//
Процедура ПривестиЗначениеСубконто(ТабличноеПоле, ДтКт, СведенияОСчете) Экспорт
	Для СчетчикСубконто = 1 По 3 Цикл
		Если СведенияОСчете.КоличествоСубконто >= СчетчикСубконто Тогда
			ТабличноеПоле.ТекущиеДанные["Субконто"+ДтКт+СчетчикСубконто] = СведенияОСчете["ТипСубконто"+СчетчикСубконто].ПривестиЗначение(ТабличноеПоле.ТекущиеДанные["Субконто"+ДтКт+СчетчикСубконто]);
		Иначе
			ТабличноеПоле.ТекущиеДанные["Субконто"+ДтКт+СчетчикСубконто] = Неопределено;
		КонецЕсли;
	КонецЦикла;
КонецПроцедуры

Функция ОпределитьВидСубконтоПоСчету(Счет, КэшВидовСубконтоПоСчетам) Экспорт
	Если Счет = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли; 
	
	Если КэшВидовСубконтоПоСчетам = Неопределено Тогда
		КэшВидовСубконтоПоСчетам = Новый Соответствие;
	КонецЕсли; 
	
	ВидыСубконтоПоСчету = КэшВидовСубконтоПоСчетам[Счет];
	Если ВидыСубконтоПоСчету = Неопределено Тогда
		ВидыСубконтоПоСчету = Счет.ВидыСубконто;
		КэшВидовСубконтоПоСчетам.Вставить(Счет, ВидыСубконтоПоСчету);
	КонецЕсли; 
	
	Возврат ВидыСубконтоПоСчету;	
КонецФункции

Функция ГоловнаяОрганизация(Организация) Экспорт
	Если Организация.Пустая() ИЛИ Организация.ГоловнаяОрганизация.Пустая() Тогда
		Возврат Организация;
	КонецЕсли;
	Возврат Организация.ГоловнаяОрганизация;
КонецФункции

Функция УдалитьПовторяющиесяЭлементыМассива(Массив, НеИспользоватьНеопределено = Ложь) Экспорт
	тзБуфер=Новый ТаблицаЗначений;
	Для каждого ЭлементМассива Из Массив Цикл
		Если НеИспользоватьНеопределено И ЭлементМассива=Неопределено Тогда
			Продолжить;
		КонецЕсли; 
		тзБуфер.Добавить();
	КонецЦикла;
	тзБуфер.Колонки.Добавить("Значения");
	тзБуфер.ЗагрузитьКолонку(Массив, "Значения");
	тзБуфер.Свернуть("Значения");
	Возврат тзБуфер.ВыгрузитьКолонку("Значения");
КонецФункции

Функция ПолучитьФамилиюИмяОтчество(Фамилия=" ", Имя=" ", Отчество=" ", ФИОКратко=Истина) Экспорт
	Если ФИОКратко Тогда
		Возврат ?(НЕ ПустаяСтрока(Фамилия), Фамилия + ?(НЕ ПустаяСтрока(Имя)," " + Лев(Имя,1) + "." + ?(НЕ ПустаяСтрока(Отчество) , Лев(Отчество,1)+".", ""), ""), "");
	КонецЕсли;	
	Возврат ?(НЕ ПустаяСтрока(Фамилия), Фамилия + ?(НЕ ПустаяСтрока(Имя)," " + Имя + ?(НЕ ПустаяСтрока(Отчество) , " " + Отчество, ""), ""), "");
КонецФункции

Функция Отладка_РБ(Регистратор, стрРегистр="Хозрасчетный") Экспорт
	НаборЗаписей=РегистрыБухгалтерии[стрРегистр].СоздатьНаборЗаписей();
	НаборЗаписей.Отбор.Регистратор.Установить(Регистратор);
	НаборЗаписей.Прочитать();
	Возврат НаборЗаписей;
КонецФункции

Функция Отладка_РН(Регистратор, стрРегистр) Экспорт
	НаборЗаписей=РегистрыНакопления[стрРегистр].СоздатьНаборЗаписей();
	НаборЗаписей.Отбор.Регистратор.Установить(Регистратор);
	НаборЗаписей.Прочитать();
	Возврат НаборЗаписей;
КонецФункции

Функция Отладка_РС(Регистратор, стрРегистр) Экспорт
	НаборЗаписей=РегистрыСведений[стрРегистр].СоздатьНаборЗаписей();
	НаборЗаписей.Отбор.Регистратор.Установить(Регистратор);
	НаборЗаписей.Прочитать();
	Возврат НаборЗаписей;
КонецФункции

Процедура УдалитьДвижениеРегистраПоРегистратору(ДокументСсылка, ИмяРегистра) Экспорт
	Если ДокументСсылка.Пустая() Тогда Возврат; КонецЕсли;
	Набор=РегистрыНакопления[ИмяРегистра].СоздатьНаборЗаписей();
	Набор.Отбор.Регистратор.Установить(ДокументСсылка);
	Набор.Прочитать();
	Если НЕ Набор.Количество()=0 Тогда
		Набор.Очистить();
	КонецЕсли;
КонецПроцедуры


// Возвращает Истина, если "функциональная" подсистема существует в конфигурации.
// Предназначена для реализации вызова необязательной подсистемы (условного вызова).
//
// У "функциональной" подсистемы снят флажок "Включать в командный интерфейс".
//
// Параметры:
//  ПолноеИмяПодсистемы - Строка - полное имя объекта метаданных подсистема
//                        без слов "Подсистема." и с учетом регистра символов.
//                        Например: "СтандартныеПодсистемы.ВариантыОтчетов".
//
// Пример:
//
//  Если ОбщегоНазначения.ПодсистемаСуществует("СтандартныеПодсистемы.ВариантыОтчетов") Тогда
//  	МодульВариантыОтчетов = ОбщегоНазначения.ОбщийМодуль("ВариантыОтчетов");
//  	МодульВариантыОтчетов.<Имя метода>();
//  КонецЕсли;
//
// Возвращаемое значение:
//  Булево.
//
Функция ПодсистемаСуществует(ПолноеИмяПодсистемы) Экспорт
	Возврат Ложь;
	
	////ИменаПодсистем=СтандартныеПодсистемыПовтИсп.ИменаПодсистем();
	////Возврат ИменаПодсистем.Получить(ПолноеИмяПодсистемы) <> Неопределено;	
КонецФункции

// Возвращает ссылку на общий модуль по имени.
//
// Параметры:
//  Имя          - Строка - имя общего модуля, например:
//                 "ОбщегоНазначения",
//                 "ОбщегоНазначенияКлиент".
//
// Возвращаемое значение:
//  ОбщийМодуль.
//
Функция ОбщийМодуль(Имя) Экспорт
	
	Если Метаданные.ОбщиеМодули.Найти(Имя) <> Неопределено Тогда
		Модуль = Вычислить(Имя); // ВычислитьВБезопасномРежиме не требуется, т.к. проверка надежная.
	ИначеЕсли СтрЧислоВхождений(Имя, ".") = 1 Тогда
		Возврат СерверныйМодульМенеджера(Имя);
	Иначе
		Модуль = Неопределено;
	КонецЕсли;
	
	Если ТипЗнч(Модуль) <> Тип("ОбщийМодуль") Тогда
		//ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(НСтр("ru = 'Общий модуль ""%1"" не найден.'"), Имя);
	КонецЕсли;
	
	Возврат Модуль;
	
КонецФункции

Функция СерверныйМодульМенеджера(Имя)
	ОбъектНайден = Ложь;
	
	ЧастиИмени = СтрРазделить(Имя, ".");
	Если ЧастиИмени.Количество() = 2 Тогда
		
		ИмяВида = ВРег(ЧастиИмени[0]);
		ИмяОбъекта = ЧастиИмени[1];
		
		Если ИмяВида = ВРег("Константы") Тогда
			Если Метаданные.Константы.Найти(ИмяОбъекта) <> Неопределено Тогда
				ОбъектНайден = Истина;
			КонецЕсли;
		ИначеЕсли ИмяВида = ВРег("РегистрыСведений") Тогда
			Если Метаданные.РегистрыСведений.Найти(ИмяОбъекта) <> Неопределено Тогда
				ОбъектНайден = Истина;
			КонецЕсли;
		ИначеЕсли ИмяВида = ВРег("РегистрыНакопления") Тогда
			Если Метаданные.РегистрыНакопления.Найти(ИмяОбъекта) <> Неопределено Тогда
				ОбъектНайден = Истина;
			КонецЕсли;
		ИначеЕсли ИмяВида = ВРег("РегистрыБухгалтерии") Тогда
			Если Метаданные.РегистрыБухгалтерии.Найти(ИмяОбъекта) <> Неопределено Тогда
				ОбъектНайден = Истина;
			КонецЕсли;
		ИначеЕсли ИмяВида = ВРег("РегистрыРасчета") Тогда
			Если Метаданные.РегистрыРасчета.Найти(ИмяОбъекта) <> Неопределено Тогда
				ОбъектНайден = Истина;
			КонецЕсли;
		ИначеЕсли ИмяВида = ВРег("Справочники") Тогда
			Если Метаданные.Справочники.Найти(ИмяОбъекта) <> Неопределено Тогда
				ОбъектНайден = Истина;
			КонецЕсли;
		ИначеЕсли ИмяВида = ВРег("Документы") Тогда
			Если Метаданные.Документы.Найти(ИмяОбъекта) <> Неопределено Тогда
				ОбъектНайден = Истина;
			КонецЕсли;
		ИначеЕсли ИмяВида = ВРег("Отчеты") Тогда
			Если Метаданные.Отчеты.Найти(ИмяОбъекта) <> Неопределено Тогда
				ОбъектНайден = Истина;
			КонецЕсли;
		ИначеЕсли ИмяВида = ВРег("Обработки") Тогда
			Если Метаданные.Обработки.Найти(ИмяОбъекта) <> Неопределено Тогда
				ОбъектНайден = Истина;
			КонецЕсли;
		ИначеЕсли ИмяВида = ВРег("БизнесПроцессы") Тогда
			Если Метаданные.БизнесПроцессы.Найти(ИмяОбъекта) <> Неопределено Тогда
				ОбъектНайден = Истина;
			КонецЕсли;
		ИначеЕсли ИмяВида = ВРег("ЖурналыДокументов") Тогда
			Если Метаданные.ЖурналыДокументов.Найти(ИмяОбъекта) <> Неопределено Тогда
				ОбъектНайден = Истина;
			КонецЕсли;
		ИначеЕсли ИмяВида = ВРег("Задачи") Тогда
			Если Метаданные.Задачи.Найти(ИмяОбъекта) <> Неопределено Тогда
				ОбъектНайден = Истина;
			КонецЕсли;
		ИначеЕсли ИмяВида = ВРег("ПланыСчетов") Тогда
			Если Метаданные.ПланыСчетов.Найти(ИмяОбъекта) <> Неопределено Тогда
				ОбъектНайден = Истина;
			КонецЕсли;
		ИначеЕсли ИмяВида = ВРег("ПланыОбмена") Тогда
			Если Метаданные.ПланыОбмена.Найти(ИмяОбъекта) <> Неопределено Тогда
				ОбъектНайден = Истина;
			КонецЕсли;
		ИначеЕсли ИмяВида = ВРег("ПланыВидовХарактеристик") Тогда
			Если Метаданные.ПланыВидовХарактеристик.Найти(ИмяОбъекта) <> Неопределено Тогда
				ОбъектНайден = Истина;
			КонецЕсли;
		ИначеЕсли ИмяВида = ВРег("ПланыВидовРасчета") Тогда
			Если Метаданные.ПланыВидовРасчета.Найти(ИмяОбъекта) <> Неопределено Тогда
				ОбъектНайден = Истина;
			КонецЕсли;
		КонецЕсли;
		
	КонецЕсли;
	
	Если Не ОбъектНайден Тогда
		ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Объект метаданных ""%1"" не найден,
			|либо для него не поддерживается получение модуля менеджера.'"), Имя);
	КонецЕсли;
	
	Модуль=Вычислить(Имя); // ВычислитьВБезопасномРежиме не требуется, т.к. проверка надежная.

	Возврат Модуль;
КонецФункции

// Проверяет, что переданное имя ИмяПроцедуры является именем экспортной процедуры конфигурации.
// Может использоваться для проверки, что переданная строка не содержит произвольного алгоритма
// на встроенном языке 1С:Предприятия перед использованием его в операторах Выполнить и Вычислить
// при их использовании для динамического вызова методов код конфигурации.
//
// В случае если переданная строка не является именем процедуры конфигурации, генерируется исключение.
//
// Предназначена для вызова из см. процедуру ВыполнитьМетодКонфигурации.
//
// Параметры:
//   ИмяПроцедуры - Строка - проверяемое имя экспортной процедуры.
//
Процедура ПроверитьИмяПроцедурыКонфигурации(Знач ИмяПроцедуры)
	
	ЧастиИмени = СтрРазделить(ИмяПроцедуры, ".");
	Если ЧастиИмени.Количество() <> 2 И ЧастиИмени.Количество() <> 3 Тогда
		ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Неправильный формат параметра ИмяПроцедуры (передано значение: ""%1"") в ОбщегоНазначения.ВыполнитьМетодКонфигурации'"), ИмяПроцедуры);
	КонецЕсли;
	
	ИмяОбъекта = ЧастиИмени[0];
	Если ЧастиИмени.Количество() = 2 И Метаданные.ОбщиеМодули.Найти(ИмяОбъекта) = Неопределено Тогда
		ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Неправильный формат параметра ИмяПроцедуры (передано значение: ""%1"") в ОбщегоНазначения.ВыполнитьМетодКонфигурации:
				|Не найден общий модуль ""%2"".'"),
			ИмяПроцедуры,
			ИмяОбъекта);
	КонецЕсли;
	
	Если ЧастиИмени.Количество() = 3 Тогда
		ПолноеИмяОбъекта = ЧастиИмени[0] + "." + ЧастиИмени[1];
		Попытка
			Менеджер = МенеджерОбъектаПоИмени(ПолноеИмяОбъекта);
		Исключение
			Менеджер = Неопределено;
		КонецПопытки;
		Если Менеджер = Неопределено Тогда
			ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
				НСтр("ru = 'Неправильный формат параметра ИмяПроцедуры (передано значение: ""%1"") в ОбщегоНазначения.ВыполнитьМетодКонфигурации:
				           |Не найден менеджер объекта ""%2"".'"),
				ИмяПроцедуры,
				ПолноеИмяОбъекта);
		КонецЕсли;
	КонецЕсли;
	
	ИмяМетодаОбъекта = ЧастиИмени[ЧастиИмени.ВГраница()];
	ВременнаяСтруктура = Новый Структура;
	Попытка
		// Проверка того, что ИмяПроцедуры является допустимым идентификатором.
		// Например: МояПроцедура.
		ВременнаяСтруктура.Вставить(ИмяМетодаОбъекта);
	Исключение
		ЗаписьЖурналаРегистрации(НСтр("ru = 'Безопасное выполнение метода'", ОбщегоНазначенияКлиентСервер.КодОсновногоЯзыка()),
			УровеньЖурналаРегистрации.Ошибка, , , ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
		ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Неправильный формат параметра ИмяПроцедуры (передано значение: ""%1"") в ОбщегоНазначения.ВыполнитьМетодКонфигурации:
			           |Имя метода ""%2"" не соответствует требованиям образования имен процедур и функций.'"),
			ИмяПроцедуры, ИмяМетодаОбъекта);
	КонецПопытки;
	
КонецПроцедуры

// Возвращает менеджер объекта по имени.
// Ограничение: не обрабатываются точки маршрутов бизнес-процессов.
//
// Параметры:
//  Имя - Строка - имя например, "Справочник", "Справочники", "Справочник.Организации".
//
// Возвращаемое значение:
//  СправочникиМенеджер, СправочникМенеджер, ДокументыМенеджер, ДокументМенеджер, ...
// 
Функция МенеджерОбъектаПоИмени(Имя)
	Перем КлассОМ, ИмяОМ, Менеджер;
	
	ЧастиИмени = СтрРазделить(Имя, ".");
	
	Если ЧастиИмени.Количество() > 0 Тогда
		КлассОМ = ВРег(ЧастиИмени[0]);
	КонецЕсли;
	
	Если ЧастиИмени.Количество() > 1 Тогда
		ИмяОМ = ЧастиИмени[1];
	КонецЕсли;
	
	Если      КлассОМ = "ПЛАНОБМЕНА"
	 Или      КлассОМ = "ПЛАНЫОБМЕНА" Тогда
		Менеджер = ПланыОбмена;
		
	ИначеЕсли КлассОМ = "СПРАВОЧНИК"
	      Или КлассОМ = "СПРАВОЧНИКИ" Тогда
		Менеджер = Справочники;
		
	ИначеЕсли КлассОМ = "ДОКУМЕНТ"
	      Или КлассОМ = "ДОКУМЕНТЫ" Тогда
		Менеджер = Документы;
		
	ИначеЕсли КлассОМ = "ЖУРНАЛДОКУМЕНТОВ"
	      Или КлассОМ = "ЖУРНАЛЫДОКУМЕНТОВ" Тогда
		Менеджер = ЖурналыДокументов;
		
	ИначеЕсли КлассОМ = "ПЕРЕЧИСЛЕНИЕ"
	      Или КлассОМ = "ПЕРЕЧИСЛЕНИЯ" Тогда
		Менеджер = Перечисления;
		
	ИначеЕсли КлассОМ = "ОБЩИЙМОДУЛЬ"
	      Или КлассОМ = "ОБЩИЕМОДУЛИ" Тогда
		
		Возврат ОбщийМодуль(ИмяОМ);
		
	ИначеЕсли КлассОМ = "ОТЧЕТ"
	      Или КлассОМ = "ОТЧЕТЫ" Тогда
		Менеджер = Отчеты;
		
	ИначеЕсли КлассОМ = "ОБРАБОТКА"
	      Или КлассОМ = "ОБРАБОТКИ" Тогда
		Менеджер = Обработки;
		
	ИначеЕсли КлассОМ = "ПЛАНВИДОВХАРАКТЕРИСТИК"
	      Или КлассОМ = "ПЛАНЫВИДОВХАРАКТЕРИСТИК" Тогда
		Менеджер = ПланыВидовХарактеристик;
		
	ИначеЕсли КлассОМ = "ПЛАНСЧЕТОВ"
	      Или КлассОМ = "ПЛАНЫСЧЕТОВ" Тогда
		Менеджер = ПланыСчетов;
		
	ИначеЕсли КлассОМ = "ПЛАНВИДОВРАСЧЕТА"
	      Или КлассОМ = "ПЛАНЫВИДОВРАСЧЕТА" Тогда
		Менеджер = ПланыВидовРасчета;
		
	ИначеЕсли КлассОМ = "РЕГИСТРСВЕДЕНИЙ"
	      Или КлассОМ = "РЕГИСТРЫСВЕДЕНИЙ" Тогда
		Менеджер = РегистрыСведений;
		
	ИначеЕсли КлассОМ = "РЕГИСТРНАКОПЛЕНИЯ"
	      Или КлассОМ = "РЕГИСТРЫНАКОПЛЕНИЯ" Тогда
		Менеджер = РегистрыНакопления;
		
	ИначеЕсли КлассОМ = "РЕГИСТРБУХГАЛТЕРИИ"
	      Или КлассОМ = "РЕГИСТРЫБУХГАЛТЕРИИ" Тогда
		Менеджер = РегистрыБухгалтерии;
		
	ИначеЕсли КлассОМ = "РЕГИСТРРАСЧЕТА"
	      Или КлассОМ = "РЕГИСТРЫРАСЧЕТА" Тогда
		
		Если ЧастиИмени.Количество() < 3 Тогда
			// Регистр расчета
			Менеджер = РегистрыРасчета;
		Иначе
			КлассПодчиненногоОМ = ВРег(ЧастиИмени[2]);
			Если ЧастиИмени.Количество() > 3 Тогда
				ИмяПодчиненногоОМ = ЧастиИмени[3];
			КонецЕсли;
			Если КлассПодчиненногоОМ = "ПЕРЕРАСЧЕТ"
			 Или КлассПодчиненногоОМ = "ПЕРЕРАСЧЕТЫ" Тогда
				// Перерасчет
				Попытка
					Менеджер = РегистрыРасчета[ИмяОМ].Перерасчеты;
					ИмяОМ = ИмяПодчиненногоОМ;
				Исключение
					Менеджер = Неопределено;
				КонецПопытки;
			КонецЕсли;
		КонецЕсли;
		
	ИначеЕсли КлассОМ = "БИЗНЕСПРОЦЕСС"
	      Или КлассОМ = "БИЗНЕСПРОЦЕССЫ" Тогда
		Менеджер = БизнесПроцессы;
		
	ИначеЕсли КлассОМ = "ЗАДАЧА"
	      Или КлассОМ = "ЗАДАЧИ" Тогда
		Менеджер = Задачи;
		
	ИначеЕсли КлассОМ = "КОНСТАНТА"
	      Или КлассОМ = "КОНСТАНТЫ" Тогда
		Менеджер = Константы;
		
	ИначеЕсли КлассОМ = "ПОСЛЕДОВАТЕЛЬНОСТЬ"
	      Или КлассОМ = "ПОСЛЕДОВАТЕЛЬНОСТИ" Тогда
		Менеджер = Последовательности;
	КонецЕсли;
	
	Если Менеджер <> Неопределено Тогда
		Если ЗначениеЗаполнено(ИмяОМ) Тогда
			Попытка
				Возврат Менеджер[ИмяОМ];
			Исключение
				Менеджер = Неопределено;
			КонецПопытки;
		Иначе
			Возврат Менеджер;
		КонецЕсли;
	КонецЕсли;
	
	ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(НСтр("ru = 'Не удалось получить менеджер для объекта ""%1""'"), Имя);
	
КонецФункции

Функция ЕстьРеквизитТабЧастиДокумента(ИмяРеквизита, МетаданныеДокумента, ИмяТабЧасти) Экспорт
	ТабЧасть=МетаданныеДокумента.ТабличныеЧасти.Найти(ИмяТабЧасти);
	Если ТабЧасть=Неопределено Тогда Возврат Ложь; КонецЕсли;
	Возврат ?(ТабЧасть.Реквизиты.Найти(ИмяРеквизита) = Неопределено, Ложь, Истина);
КонецФункции


// Удаляет битые ссылки из переменной.
//
// Параметры:
//   СсылкаИлиКоллекция - ЛюбаяСсылка, Произвольный - Проверяемый объект или очищаемая коллекция.
//
// Возвращаемое значение: 
//   Булево - 
//       * Истина - СсылкаИлиКоллекция ссылочного типа и объект не найден в базе данных.
//       * Ложь - Когда СсылкаИлиКоллекция не ссылочного типа или объект найден в базе данных.
//
Функция УдалитьБитыеСсылки(СсылкаИлиКоллекция)
	
	Тип = ТипЗнч(СсылкаИлиКоллекция);
	
	Если Тип = Тип("Неопределено") Или Тип = Тип("Булево") Или Тип = Тип("Строка") Или Тип = Тип("Число") Или Тип = Тип("Дата") Тогда // Оптимизация - часто используемые примитивные типы.
		Возврат Ложь; // Не ссылка.
		
	ИначеЕсли Тип = Тип("Массив") Тогда
		Количество = СсылкаИлиКоллекция.Количество();
		Для Номер = 1 По Количество Цикл
			ОбратныйИндекс = Количество - Номер;
			Значение = СсылкаИлиКоллекция[ОбратныйИндекс];
			Если УдалитьБитыеСсылки(Значение) Тогда
				СсылкаИлиКоллекция.Удалить(ОбратныйИндекс);
			КонецЕсли;
		КонецЦикла;
		
		Возврат Ложь; // Не ссылка.

	ИначеЕсли Тип = Тип("Структура") Или Тип = Тип("Соответствие") Тогда
		Для Каждого КлючИЗначение Из СсылкаИлиКоллекция Цикл
			Значение = КлючИЗначение.Значение;
			Если УдалитьБитыеСсылки(Значение) Тогда
				СсылкаИлиКоллекция.Вставить(КлючИЗначение.Ключ, Неопределено);
			КонецЕсли;
		КонецЦикла;
		
		Возврат Ложь; // Не ссылка.
		
	ИначеЕсли Документы.ТипВсеСсылки().СодержитТип(Тип)
		Или Справочники.ТипВсеСсылки().СодержитТип(Тип)
		Или Перечисления.ТипВсеСсылки().СодержитТип(Тип)
		Или ПланыВидовХарактеристик.ТипВсеСсылки().СодержитТип(Тип)
		Или ПланыСчетов.ТипВсеСсылки().СодержитТип(Тип)
		Или ПланыВидовРасчета.ТипВсеСсылки().СодержитТип(Тип)
		Или ПланыОбмена.ТипВсеСсылки().СодержитТип(Тип)
		Или БизнесПроцессы.ТипВсеСсылки().СодержитТип(Тип)
		Или Задачи.ТипВсеСсылки().СодержитТип(Тип) Тогда
		// Ссылочный тип, исключая ТочкаМаршрутаБизнесПроцессаСсылка.
		
		Если СсылкаИлиКоллекция.Пустая() Тогда
			Возврат Ложь; // Ссылка пустая.
		ИначеЕсли ЗначениеРеквизитаОбъекта(СсылкаИлиКоллекция, "Ссылка") = Неопределено Тогда
			СсылкаИлиКоллекция = Неопределено;
			Возврат Истина; // "Битая" ссылка.
		КонецЕсли;

		Возврат Ложь; // Объект найден.		
	КонецЕсли;
	
	Возврат Ложь; // Не ссылка.			
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// Хранилища настроек.

Процедура ХранилищеСохранить(МенеджерХранилища, КлючОбъекта, КлючНастроек, Настройки, ОписаниеНастроек, ИмяПользователя, ОбновитьПовторноИспользуемыеЗначения)
	//*** Если Не ПравоДоступа("СохранениеДанныхПользователя", Метаданные) Тогда Возврат; КонецЕсли;
	
	МенеджерХранилища.Сохранить(КлючОбъекта, КлючНастроек(КлючНастроек), Настройки, ОписаниеНастроек, ИмяПользователя);

	Если ОбновитьПовторноИспользуемыеЗначения Тогда
		ОбновитьПовторноИспользуемыеЗначения();
	КонецЕсли;	
КонецПроцедуры

Функция ХранилищеЗагрузить(МенеджерХранилища, КлючОбъекта, КлючНастроек, ЗначениеПоУмолчанию, ОписаниеНастроек, ИмяПользователя)
	//Результат=Неопределено;
	//Если ПравоДоступа("СохранениеДанныхПользователя", Метаданные) Тогда
		Результат = МенеджерХранилища.Загрузить(КлючОбъекта, КлючНастроек(КлючНастроек), ОписаниеНастроек, ИмяПользователя);
	//КонецЕсли;
	
	Если Результат = Неопределено Тогда
		Результат = ЗначениеПоУмолчанию;
	Иначе
		УстановитьПривилегированныйРежим(Истина);
		Если УдалитьБитыеСсылки(Результат) Тогда
			Результат = ЗначениеПоУмолчанию;
		КонецЕсли;
	КонецЕсли;
	
	Возврат Результат;	
КонецФункции

Процедура ХранилищеУдалить(МенеджерХранилища, КлючОбъекта, КлючНастроек, ИмяПользователя)
	//Если ПравоДоступа("СохранениеДанныхПользователя", Метаданные) Тогда
		МенеджерХранилища.Удалить(КлючОбъекта, КлючНастроек(КлючНастроек), ИмяПользователя);
	//КонецЕсли;	
КонецПроцедуры

// Возвращает строку ключа настроек, не превышающую допустимую длину 128 символов.
// Если указанная строка превышает 128, тогда вместо символов сверх 96 символов
// добавляется их хеш-сумма по алгоритму MD5 размером 32 символа.
//
// Параметры:
//  Строка - Строка - строка произвольной длины.
//
// Возвращаемое значение:
//  Строка - не более 128 символов.
//
Функция КлючНастроек(Знач Строка)
	Возврат СократитьСтрокуКонтрольнойСуммой(Строка, 128);
КонецФункции

// Сокращает строку до нужной длины, при этом обрезанная часть хешируется,
// обеспечивая уникальность строки. Проверяет длину строки на входе и, в случае
// превышения максимальной длины, преобразует ее конец по алгоритму MD5 в
// уникальную строку из 32 символов.
//
// Параметры:
//  Строка            - Строка - исходная строка произвольной длины.
//  МаксимальнаяДлина - Число  - требуемое максимальное количество символов в строке,
//                               минимальное значение: 32.
// 
// Возвращаемое значение:
//   Строка - строка, не превышающая максимальную длину.
//
Функция СократитьСтрокуКонтрольнойСуммой(Строка, МаксимальнаяДлина) Экспорт
	ОбщегоНазначенияКлиентСервер.Проверить(МаксимальнаяДлина >= 32, НСтр("ru = 'Параметр МаксимальнаяДлина не может быть меньше 32'"),	"ОбщегоНазначения.СократитьСтрокуКонтрольнойСуммой");

	Результат = Строка;
	Если СтрДлина(Строка) > МаксимальнаяДлина Тогда
		Результат = Лев(Строка, МаксимальнаяДлина - 32);
		ХешированиеДанных = Новый ХешированиеДанных(ХешФункция.MD5);
		ХешированиеДанных.Добавить(Сред(Строка, МаксимальнаяДлина - 32 + 1));
		Результат = Результат + СтрЗаменить(ХешированиеДанных.ХешСумма, " ", "");
	КонецЕсли;
	Возврат Результат;
КонецФункции

// Сохраняет настройку в хранилище общих настроек, как метод платформы Сохранить,
// объектов СтандартноеХранилищеНастроекМенеджер или ХранилищеНастроекМенеджер.<Имя хранилища>,
// но с поддержкой длины ключа настроек более 128 символов путем хеширования части,
// которая превышает 96 символов.
// Если нет права СохранениеДанныхПользователя, сохранение пропускается без ошибки.
//
// Параметры:
//   КлючОбъекта       - Строка           - см. синтакс-помощник платформы.
//   КлючНастроек      - Строка           - см. синтакс-помощник платформы.
//   Настройки         - Произвольный     - см. синтакс-помощник платформы.
//   ОписаниеНастроек  - ОписаниеНастроек - см. синтакс-помощник платформы.
//   ИмяПользователя   - Строка           - см. синтакс-помощник платформы.
//   ОбновитьПовторноИспользуемыеЗначения - Булево - выполнить одноименный метод платформы.
//
Процедура ХранилищеОбщихНастроекСохранить(КлючОбъекта, КлючНастроек, Настройки, ОписаниеНастроек = Неопределено, ИмяПользователя = Неопределено, ОбновитьПовторноИспользуемыеЗначения = Ложь) Экспорт
	ХранилищеСохранить(ХранилищеОбщихНастроек, КлючОбъекта, КлючНастроек, Настройки, ОписаниеНастроек, ИмяПользователя,	ОбновитьПовторноИспользуемыеЗначения);
КонецПроцедуры

// Сохраняет несколько настроек в хранилище общих настроек, как метод платформы Сохранить,
// объектов СтандартноеХранилищеНастроекМенеджер или ХранилищеНастроекМенеджер.<Имя хранилища>,
// но с поддержкой длины ключа настроек более 128 символов путем хеширования части,
// которая превышает 96 символов.
// Если нет права СохранениеДанныхПользователя, сохранение пропускается без ошибки.
// 
// Параметры:
//   НесколькоНастроек - Массив - со значениями:
//     * Значение - Структура - со свойствами:
//         * Объект    - Строка       - см. параметр КлючОбъекта  в синтакс-помощнике платформы.
//         * Настройка - Строка       - см. параметр КлючНастроек в синтакс-помощнике платформы.
//         * Значение  - Произвольный - см. параметр Настройки    в синтакс-помощнике платформы.
//
//   ОбновитьПовторноИспользуемыеЗначения - Булево - выполнить одноименный метод платформы.
//
Процедура ХранилищеОбщихНастроекСохранитьМассив(НесколькоНастроек, ОбновитьПовторноИспользуемыеЗначения = Ложь) Экспорт
	//Если Не ПравоДоступа("СохранениеДанныхПользователя", Метаданные) Тогда Возврат; КонецЕсли;
	
	Для Каждого Элемент Из НесколькоНастроек Цикл
		ХранилищеОбщихНастроек.Сохранить(Элемент.Объект, КлючНастроек(Элемент.Настройка), Элемент.Значение);
	КонецЦикла;
	
	Если ОбновитьПовторноИспользуемыеЗначения Тогда
		ОбновитьПовторноИспользуемыеЗначения();
	КонецЕсли;	
КонецПроцедуры

// Загружает настройку из хранилища общих настроек, как метод платформы Загрузить,
// объектов СтандартноеХранилищеНастроекМенеджер или ХранилищеНастроекМенеджер.<Имя хранилища>,
// но с поддержкой длины ключа настроек более 128 символов путем хеширования части,
// которая превышает 96 символов.
// Кроме того, возвращает указанное значение по умолчанию, если настройки не найдены.
// Если нет права СохранениеДанныхПользователя, возвращается значение по умолчанию без ошибки.
//
// В возвращаемом значении очищаются ссылки на несуществующий объект в базе данных, а именно
// - возвращаемая ссылка заменяется на указанное значение по умолчанию;
// - из данных типа Массив ссылки удаляются;
// - у данных типа Структура и Соответствие ключ не меняется, а значение устанавливается Неопределено;
// - анализ значений в данных типа Массив, Структура, Соответствие выполняется рекурсивно.
//
// Параметры:
//   КлючОбъекта          - Строка           - см. синтакс-помощник платформы.
//   КлючНастроек         - Строка           - см. синтакс-помощник платформы.
//   ЗначениеПоУмолчанию  - Произвольный     - значение, которое возвращается, если настройки не найдены.
//                                             Если не указано, возвращается значение Неопределено.
//   ОписаниеНастроек     - ОписаниеНастроек - см. синтакс-помощник платформы.
//   ИмяПользователя      - Строка           - см. синтакс-помощник платформы.
//
// Возвращаемое значение: 
//   Произвольный - см. синтакс-помощник платформы.
//
Функция ХранилищеОбщихНастроекЗагрузить(КлючОбъекта, КлючНастроек, ЗначениеПоУмолчанию = Неопределено, 	ОписаниеНастроек = Неопределено, ИмяПользователя = Неопределено) Экспорт
	Возврат ХранилищеЗагрузить(ХранилищеОбщихНастроек, КлючОбъекта, КлючНастроек, ЗначениеПоУмолчанию, ОписаниеНастроек, ИмяПользователя);	
КонецФункции

// Удаляет настройку из хранилища общих настроек, как метод платформы Удалить,
// объектов СтандартноеХранилищеНастроекМенеджер или ХранилищеНастроекМенеджер.<Имя хранилища>,
// но с поддержкой длины ключа настроек более 128 символов путем хеширования части,
// которая превышает 96 символов.
// Если нет права СохранениеДанныхПользователя, удаление пропускается без ошибки.
//
// Параметры:
//   КлючОбъекта     - Строка, Неопределено - см. синтакс-помощник платформы.
//   КлючНастроек    - Строка, Неопределено - см. синтакс-помощник платформы.
//   ИмяПользователя - Строка, Неопределено - см. синтакс-помощник платформы.
//
Процедура ХранилищеОбщихНастроекУдалить(КлючОбъекта, КлючНастроек, ИмяПользователя) Экспорт	
	ХранилищеУдалить(ХранилищеОбщихНастроек, КлючОбъекта, КлючНастроек, ИмяПользователя);
КонецПроцедуры

// Сохраняет настройку в хранилище системных настроек, как метод платформы Сохранить
// объекта СтандартноеХранилищеНастроекМенеджер, но с поддержкой длины ключа настроек
// более 128 символов путем хеширования части, которая превышает 96 символов.
// Если нет права СохранениеДанныхПользователя, сохранение пропускается без ошибки.
//
// Параметры:
//   КлючОбъекта       - Строка           - см. синтакс-помощник платформы.
//   КлючНастроек      - Строка           - см. синтакс-помощник платформы.
//   Настройки         - Произвольный     - см. синтакс-помощник платформы.
//   ОписаниеНастроек  - ОписаниеНастроек - см. синтакс-помощник платформы.
//   ИмяПользователя   - Строка           - см. синтакс-помощник платформы.
//   ОбновитьПовторноИспользуемыеЗначения - Булево - выполнить одноименный метод платформы.
//
Процедура ХранилищеСистемныхНастроекСохранить(КлючОбъекта, КлючНастроек, Настройки, ОписаниеНастроек = Неопределено, ИмяПользователя = Неопределено, ОбновитьПовторноИспользуемыеЗначения = Ложь) Экспорт	
	ХранилищеСохранить(ХранилищеСистемныхНастроек, КлючОбъекта, КлючНастроек, Настройки, ОписаниеНастроек, ИмяПользователя, ОбновитьПовторноИспользуемыеЗначения);	
КонецПроцедуры

// Загружает настройку из хранилища системных настроек, как метод платформы Загрузить,
// объекта СтандартноеХранилищеНастроекМенеджер, но с поддержкой длины ключа настроек
// более 128 символов путем хеширования части, которая превышает 96 символов.
// Кроме того, возвращает указанное значение по умолчанию, если настройки не найдены.
// Если нет права СохранениеДанныхПользователя, возвращается значение по умолчанию без ошибки.
//
// В возвращаемом значении очищаются ссылки на несуществующий объект в базе данных, а именно
// - возвращаемая ссылка заменяется на указанное значение по умолчанию;
// - из данных типа Массив ссылки удаляются;
// - у данных типа Структура и Соответствие ключ не меняется, а значение устанавливается Неопределено;
// - анализ значений в данных типа Массив, Структура, Соответствие выполняется рекурсивно.
//
// Параметры:
//   КлючОбъекта          - Строка           - см. синтакс-помощник платформы.
//   КлючНастроек         - Строка           - см. синтакс-помощник платформы.
//   ЗначениеПоУмолчанию  - Произвольный     - значение, которое возвращается, если настройки не найдены.
//                                             Если не указано, возвращается значение Неопределено.
//   ОписаниеНастроек     - ОписаниеНастроек - см. синтакс-помощник платформы.
//   ИмяПользователя      - Строка           - см. синтакс-помощник платформы.
//
// Возвращаемое значение: 
//   Произвольный - см. синтакс-помощник платформы.
//
Функция ХранилищеСистемныхНастроекЗагрузить(КлючОбъекта, КлючНастроек, ЗначениеПоУмолчанию = Неопределено, ОписаниеНастроек = Неопределено, ИмяПользователя = Неопределено) Экспорт
	Возврат ХранилищеЗагрузить(ХранилищеСистемныхНастроек, КлючОбъекта, КлючНастроек, ЗначениеПоУмолчанию, ОписаниеНастроек, ИмяПользователя);	
КонецФункции

// Удаляет настройку из хранилища системных настроек, как метод платформы Удалить,
// объекта СтандартноеХранилищеНастроекМенеджер, но с поддержкой длины ключа настроек
// более 128 символов путем хеширования части, которая превышает 96 символов.
// Если нет права СохранениеДанныхПользователя, удаление пропускается без ошибки.
//
// Параметры:
//   КлючОбъекта     - Строка, Неопределено - см. синтакс-помощник платформы.
//   КлючНастроек    - Строка, Неопределено - см. синтакс-помощник платформы.
//   ИмяПользователя - Строка, Неопределено - см. синтакс-помощник платформы.
//
Процедура ХранилищеСистемныхНастроекУдалить(КлючОбъекта, КлючНастроек, ИмяПользователя) Экспорт
	ХранилищеУдалить(ХранилищеСистемныхНастроек, КлючОбъекта, КлючНастроек,	ИмяПользователя);	
КонецПроцедуры

// Сохраняет настройку в хранилище настроек данных форм, как метод платформы Сохранить,
// объектов СтандартноеХранилищеНастроекМенеджер или ХранилищеНастроекМенеджер.<Имя хранилища>,
// но с поддержкой длины ключа настроек более 128 символов путем хеширования части,
// которая превышает 96 символов.
// Если нет права СохранениеДанныхПользователя, сохранение пропускается без ошибки.
//
// Параметры:
//   КлючОбъекта       - Строка           - см. синтакс-помощник платформы.
//   КлючНастроек      - Строка           - см. синтакс-помощник платформы.
//   Настройки         - Произвольный     - см. синтакс-помощник платформы.
//   ОписаниеНастроек  - ОписаниеНастроек - см. синтакс-помощник платформы.
//   ИмяПользователя   - Строка           - см. синтакс-помощник платформы.
//   ОбновитьПовторноИспользуемыеЗначения - Булево - выполнить одноименный метод платформы.
//
Процедура ХранилищеНастроекДанныхФормСохранить(КлючОбъекта, КлючНастроек, Настройки, ОписаниеНастроек = Неопределено, ИмяПользователя = Неопределено,  ОбновитьПовторноИспользуемыеЗначения = Ложь) Экспорт
	ХранилищеСохранить(ХранилищеНастроекДанныхФорм, КлючОбъекта, КлючНастроек, Настройки, ОписаниеНастроек, ИмяПользователя, ОбновитьПовторноИспользуемыеЗначения);	
КонецПроцедуры

// Загружает настройку из хранилища настроек данных форм, как метод платформы Загрузить,
// объектов СтандартноеХранилищеНастроекМенеджер или ХранилищеНастроекМенеджер.<Имя хранилища>,
// но с поддержкой длины ключа настроек более 128 символов путем хеширования части,
// которая превышает 96 символов.
// Кроме того, возвращает указанное значение по умолчанию, если настройки не найдены.
// Если нет права СохранениеДанныхПользователя, возвращается значение по умолчанию без ошибки.
//
// В возвращаемом значении очищаются ссылки на несуществующий объект в базе данных, а именно
// - возвращаемая ссылка заменяется на указанное значение по умолчанию;
// - из данных типа Массив ссылки удаляются;
// - у данных типа Структура и Соответствие ключ не меняется, а значение устанавливается Неопределено;
// - анализ значений в данных типа Массив, Структура, Соответствие выполняется рекурсивно.
//
// Параметры:
//   КлючОбъекта          - Строка           - см. синтакс-помощник платформы.
//   КлючНастроек         - Строка           - см. синтакс-помощник платформы.
//   ЗначениеПоУмолчанию  - Произвольный     - значение, которое возвращается, если настройки не найдены.
//                                             Если не указано, возвращается значение Неопределено.
//   ОписаниеНастроек     - ОписаниеНастроек - см. синтакс-помощник платформы.
//   ИмяПользователя      - Строка           - см. синтакс-помощник платформы.
//
// Возвращаемое значение: 
//   Произвольный - см. синтакс-помощник платформы.
//
Функция ХранилищеНастроекДанныхФормЗагрузить(КлючОбъекта, КлючНастроек, ЗначениеПоУмолчанию = Неопределено,  ОписаниеНастроек = Неопределено, ИмяПользователя = Неопределено) Экспорт
	Возврат ХранилищеЗагрузить(ХранилищеНастроекДанныхФорм, КлючОбъекта, КлючНастроек, ЗначениеПоУмолчанию, ОписаниеНастроек, ИмяПользователя);
КонецФункции

// Удаляет настройку из хранилища настроек данных форм, как метод платформы Удалить,
// объектов СтандартноеХранилищеНастроекМенеджер или ХранилищеНастроекМенеджер.<Имя хранилища>,
// но с поддержкой длины ключа настроек более 128 символов путем хеширования части,
// которая превышает 96 символов.
// Если нет права СохранениеДанныхПользователя, удаление пропускается без ошибки.
//
// Параметры:
//   КлючОбъекта     - Строка, Неопределено - см. синтакс-помощник платформы.
//   КлючНастроек    - Строка, Неопределено - см. синтакс-помощник платформы.
//   ИмяПользователя - Строка, Неопределено - см. синтакс-помощник платформы.
//
Процедура ХранилищеНастроекДанныхФормУдалить(КлючОбъекта, КлючНастроек, ИмяПользователя) Экспорт
	ХранилищеУдалить(ХранилищеНастроекДанныхФорм, КлючОбъекта, КлючНастроек, ИмяПользователя);	
КонецПроцедуры

